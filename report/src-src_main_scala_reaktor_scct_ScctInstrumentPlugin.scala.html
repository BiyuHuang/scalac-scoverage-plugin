<table class="classes"><tbody><tr>
      <td class="barContainerLeft"><a href="#">&#x200B;reaktor/&#x200B;scct/<span class="header">&#x200B;ScctInstrumentPlugin.scala</span></a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">89 %</div>
        <div class="greenBar" style="width:178px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctInstrumentPlugin"><img src="class.png"></img>ScctInstrumentPlugin</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">53 %</div>
        <div class="greenBar" style="width:106px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctInstrumentPluginOptions"><img src="class.png"></img>ScctInstrumentPluginOptions</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Object_reaktor_scct_ScctInstrumentPluginOptions"><img src="object.png"></img>ScctInstrumentPluginOptions</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">75 %</div>
        <div class="greenBar" style="width:150px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent"><img src="class.png"></img>ScctTransformComponent</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">79 %</div>
        <div class="greenBar" style="width:158px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent_ClassRegisterer"><img src="class.png"></img>ScctTransformComponent.ClassRegisterer</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent_Instrumenter"><img src="class.png"></img>ScctTransformComponent.Instrumenter</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">96 %</div>
        <div class="greenBar" style="width:192px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent_MinimumOffsetFinder"><img src="class.png"></img>ScctTransformComponent.MinimumOffsetFinder</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr></tbody></table><table class="source"><tbody><tr>
            <td class="black">1</td>
            <td>package reaktor.scct
</td>
          </tr><tr>
            <td class="black">2</td>
            <td>
</td>
          </tr><tr>
            <td class="black">3</td>
            <td>import tools.nsc.plugins.{PluginComponent, Plugin}
</td>
          </tr><tr>
            <td class="black">4</td>
            <td>import java.io.File
</td>
          </tr><tr>
            <td class="black">5</td>
            <td>import tools.nsc.transform.{Transform, TypingTransformers}
</td>
          </tr><tr>
            <td class="black">6</td>
            <td>import tools.nsc.symtab.Flags
</td>
          </tr><tr>
            <td class="black">7</td>
            <td>import tools.nsc.{Phase, Global}
</td>
          </tr><tr>
            <td class="black">8</td>
            <td>
</td>
          </tr><tr>
            <td class="green">9</td>
            <td><a id="Class_reaktor_scct_ScctInstrumentPlugin"></a>class ScctInstrumentPlugin(val global: Global) extends Plugin {
</td>
          </tr><tr>
            <td class="green">10</td>
            <td>  val name = &quot;scct&quot;
</td>
          </tr><tr>
            <td class="green">11</td>
            <td>  val description = &quot;Scala code coverage instrumentation plugin.&quot;
</td>
          </tr><tr>
            <td class="green">12</td>
            <td>  val runsAfter = List(&quot;refchecks&quot;)
</td>
          </tr><tr>
            <td class="black">13</td>
            <td>
</td>
          </tr><tr>
            <td class="green">14</td>
            <td>  val options = new ScctInstrumentPluginOptions()
</td>
          </tr><tr>
            <td class="green">15</td>
            <td>  val components = List(new ScctTransformComponent(global, options))
</td>
          </tr><tr>
            <td class="black">16</td>
            <td>
</td>
          </tr><tr>
            <td class="black">17</td>
            <td>  override def processOptions(opts: List[String], error: String =&gt; Unit) {
</td>
          </tr><tr>
            <td class="red">18</td>
            <td>    for (<span class="non">opt &lt;- opts) {
</span></td>
          </tr><tr>
            <td class="red">19</td>
            <td>      if (<span class="non">opt.startsWith(&quot;projectId:&quot;)) {
</span></td>
          </tr><tr>
            <td class="red">20</td>
            <td>        <span class="non">options.projectId = opt.substring(&quot;projectId:&quot;.length)
</span></td>
          </tr><tr>
            <td class="red">21</td>
            <td>      } else if (<span class="non">opt.startsWith(&quot;basedir:&quot;)) {
</span></td>
          </tr><tr>
            <td class="red">22</td>
            <td>        <span class="non">options.baseDir = new File(opt.substring(&quot;basedir:&quot;.length))
</span></td>
          </tr><tr>
            <td class="black">23</td>
            <td>      } else {
</td>
          </tr><tr>
            <td class="red">24</td>
            <td>        <span class="non">error(&quot;Unknown option: &quot;+opt)
</span></td>
          </tr><tr>
            <td class="black">25</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">26</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">27</td>
            <td>  }
</td>
          </tr><tr>
            <td class="green">28</td>
            <td>  override val optionsHelp: Option[String] = Some(
</td>
          </tr><tr>
            <td class="black">29</td>
            <td>    &quot;  -P:scct:projectId:&lt;name&gt;          identify compiled classes under project &lt;name&gt;\n&quot; +
</td>
          </tr><tr>
            <td class="black">30</td>
            <td>    &quot;  -P:scct:basedir:&lt;dir&gt;             set the root dir of the project being compiled&quot;
</td>
          </tr><tr>
            <td class="black">31</td>
            <td>  )
</td>
          </tr><tr>
            <td class="black">32</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">33</td>
            <td>
</td>
          </tr><tr>
            <td class="green">34</td>
            <td><a id="Class_reaktor_scct_ScctInstrumentPluginOptions"></a>class ScctInstrumentPluginOptions(var projectId:String, var baseDir:File) {
</td>
          </tr><tr>
            <td class="green">35</td>
            <td>  def this() = this(ScctInstrumentPluginOptions.defaultProjectName, ScctInstrumentPluginOptions.defaultBasedir)
</td>
          </tr><tr>
            <td class="black">36</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">37</td>
            <td>
</td>
          </tr><tr>
            <td class="black">38</td>
            <td><a id="Object_reaktor_scct_ScctInstrumentPluginOptions"></a>object ScctInstrumentPluginOptions {
</td>
          </tr><tr>
            <td class="black">39</td>
            <td>  def defaultBasedir = {
</td>
          </tr><tr>
            <td class="green">40</td>
            <td>    new File(System.getProperty(&quot;scct.basedir&quot;, System.getProperty(&quot;user.dir&quot;, &quot;.&quot;)))
</td>
          </tr><tr>
            <td class="black">41</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">42</td>
            <td>  def defaultProjectName = {
</td>
          </tr><tr>
            <td class="yellow">43</td>
            <td>    if (defaultBasedir.exists) defaultBasedir.getName else <span class="non">&quot;default&quot;
</span></td>
          </tr><tr>
            <td class="black">44</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">45</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">46</td>
            <td>
</td>
          </tr><tr>
            <td class="green">47</td>
            <td><a id="Class_reaktor_scct_ScctTransformComponent"></a>class ScctTransformComponent(val global: Global, val opts:ScctInstrumentPluginOptions) extends PluginComponent with TypingTransformers with Transform {
</td>
          </tr><tr>
            <td class="black">48</td>
            <td>  import global._
</td>
          </tr><tr>
            <td class="black">49</td>
            <td>  import global.definitions._
</td>
          </tr><tr>
            <td class="green">50</td>
            <td>  override val runsRightAfter = Some(&quot;refchecks&quot;)
</td>
          </tr><tr>
            <td class="green">51</td>
            <td>  val runsAfter = List[String](runsRightAfter.get)
</td>
          </tr><tr>
            <td class="green">52</td>
            <td>  val phaseName = &quot;scctInstrumentation&quot;
</td>
          </tr><tr>
            <td class="green">53</td>
            <td>  def newTransformer(unit: CompilationUnit) = new Instrumenter(unit)
</td>
          </tr><tr>
            <td class="black">54</td>
            <td>
</td>
          </tr><tr>
            <td class="green">55</td>
            <td>  var debug = false
</td>
          </tr><tr>
            <td class="green">56</td>
            <td>  var saveData = true
</td>
          </tr><tr>
            <td class="green">57</td>
            <td>  var counter = 0L
</td>
          </tr><tr>
            <td class="green">58</td>
            <td>  var data: List[CoveredBlock] = Nil
</td>
          </tr><tr>
            <td class="red">59</td>
            <td>  lazy val coverageFile = <span class="non">new File(global.settings.outdir.value, &quot;coverage.data&quot;)
</span></td>
          </tr><tr>
            <td class="green">60</td>
            <td>  def newId = { counter += 1; counter.toString }
</td>
          </tr><tr>
            <td class="black">61</td>
            <td>
</td>
          </tr><tr>
            <td class="green">62</td>
            <td>  override def newPhase(prev: scala.tools.nsc.Phase): StdPhase = new Phase(prev) {
</td>
          </tr><tr>
            <td class="black">63</td>
            <td>    override def run {
</td>
          </tr><tr>
            <td class="black">64</td>
            <td>      super.run
</td>
          </tr><tr>
            <td class="black">65</td>
            <td>      saveMetadata
</td>
          </tr><tr>
            <td class="black">66</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">67</td>
            <td>    private def saveMetadata {
</td>
          </tr><tr>
            <td class="black">68</td>
            <td>      if (saveData) {
</td>
          </tr><tr>
            <td class="black">69</td>
            <td>        println(&quot;[&quot; + opts.projectId + &quot;] scct: Saving coverage data.&quot;)
</td>
          </tr><tr>
            <td class="black">70</td>
            <td>        if (coverageFile.exists) coverageFile.delete
</td>
          </tr><tr>
            <td class="black">71</td>
            <td>        MetadataPickler.toFile(data, coverageFile)
</td>
          </tr><tr>
            <td class="black">72</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">73</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">74</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">75</td>
            <td>
</td>
          </tr><tr>
            <td class="green">76</td>
            <td><a id="Class_reaktor_scct_ScctTransformComponent_Instrumenter"></a>  class Instrumenter(unit: CompilationUnit) extends TypingTransformer(unit) {
</td>
          </tr><tr>
            <td class="black">77</td>
            <td>
</td>
          </tr><tr>
            <td class="black">78</td>
            <td>    override def transformUnit(unit: CompilationUnit) {
</td>
          </tr><tr>
            <td class="yellow">79</td>
            <td>      if (debug) <span class="non">treeBrowser.browse(&quot;scct&quot;, List(unit))
</span></td>
          </tr><tr>
            <td class="green">80</td>
            <td>      registerClasses(unit)
</td>
          </tr><tr>
            <td class="green">81</td>
            <td>      super.transformUnit(unit)
</td>
          </tr><tr>
            <td class="yellow">82</td>
            <td>      if (debug) <span class="non">treeBrowser.browse(&quot;scct&quot;, List(unit))
</span></td>
          </tr><tr>
            <td class="black">83</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">84</td>
            <td>
</td>
          </tr><tr>
            <td class="black">85</td>
            <td>    override def transform(tree: Tree) = {
</td>
          </tr><tr>
            <td class="green">86</td>
            <td>      val (continue, result) = preprocess(tree)
</td>
          </tr><tr>
            <td class="green">87</td>
            <td>      if (continue) super.transform(result) else result
</td>
          </tr><tr>
            <td class="black">88</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">89</td>
            <td>
</td>
          </tr><tr>
            <td class="green">90</td>
            <td>    private def hasSkipAnnotation(t: Tree) = t.hasSymbol &amp;&amp; t.symbol.hasAnnotation(definitions.getClass(&quot;reaktor.scct.uncovered&quot;))
</td>
          </tr><tr>
            <td class="green">91</td>
            <td>    private def isSynthetic(t: Tree) = t.hasSymbol &amp;&amp; t.symbol.isSynthetic &amp;&amp; !t.symbol.isAnonymousFunction
</td>
          </tr><tr>
            <td class="green">92</td>
            <td>    private def isObjectOrTraitConstructor(s: Symbol) = s.isConstructor &amp;&amp; (currentClass.isModuleClass || currentClass.isTrait)
</td>
          </tr><tr>
            <td class="green">93</td>
            <td>    private def isGeneratedMethod(t: DefDef) = !t.symbol.isConstructor &amp;&amp; t.pos.point == currentClass.pos.point
</td>
          </tr><tr>
            <td class="green">94</td>
            <td>    private def isAbstractMethod(t: DefDef) = t.symbol.isDeferred
</td>
          </tr><tr>
            <td class="green">95</td>
            <td>    private def isNonLazyStableMethodOrAccessor(t: DefDef) = !t.symbol.isLazy &amp;&amp; (t.symbol.isStable || t.symbol.hasFlag(Flags.ACCESSOR))
</td>
          </tr><tr>
            <td class="green">96</td>
            <td>    private def isInAnonymousClass = currentClass.isAnonymousClass
</td>
          </tr><tr>
            <td class="black">97</td>
            <td>
</td>
          </tr><tr>
            <td class="green">98</td>
            <td>    def preprocess(t: Tree): Tuple2[Boolean, Tree] = t match {
</td>
          </tr><tr>
            <td class="green">99</td>
            <td>      case _ if isSynthetic(t) =&gt; (false, t)
</td>
          </tr><tr>
            <td class="green">100</td>
            <td>      case _ if hasSkipAnnotation(t) =&gt; (false, t)
</td>
          </tr><tr>
            <td class="green">101</td>
            <td>      case dd: DefDef if isNonLazyStableMethodOrAccessor(dd) =&gt; (false, t)
</td>
          </tr><tr>
            <td class="green">102</td>
            <td>      case dd: DefDef if isAbstractMethod(dd) =&gt; (false, t)
</td>
          </tr><tr>
            <td class="green">103</td>
            <td>      case dd: DefDef if isObjectOrTraitConstructor(t.symbol) =&gt; (false, t)
</td>
          </tr><tr>
            <td class="green">104</td>
            <td>      case dd: DefDef if isGeneratedMethod(dd) =&gt; (false, t)
</td>
          </tr><tr>
            <td class="green">105</td>
            <td>      case dd: DefDef if isInAnonymousClass =&gt; (false, t)
</td>
          </tr><tr>
            <td class="black">106</td>
            <td>
</td>
          </tr><tr>
            <td class="green">107</td>
            <td>      case dd: DefDef if (t.symbol.isConstructor) =&gt; {
</td>
          </tr><tr>
            <td class="green">108</td>
            <td>        (false, instrumentConstructor(t.symbol.isPrimaryConstructor, dd))
</td>
          </tr><tr>
            <td class="black">109</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">110</td>
            <td>      case dd @ DefDef(_,_,_,_,_,b @ Block(List(a @ Assign(lhs,rhs)), _)) if (t.symbol.isLazy) =&gt; {
</td>
          </tr><tr>
            <td class="green">111</td>
            <td>        val newAssign = treeCopy.Assign(a, lhs, recurse(rhs))
</td>
          </tr><tr>
            <td class="green">112</td>
            <td>        val newBlock = treeCopy.Block(b, List(newAssign), b.expr)
</td>
          </tr><tr>
            <td class="green">113</td>
            <td>        (false, treeCopy.DefDef(t, dd.mods, dd.name, dd.tparams, dd.vparamss, dd.tpt, newBlock))
</td>
          </tr><tr>
            <td class="black">114</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">115</td>
            <td>      case dd: DefDef =&gt; {
</td>
          </tr><tr>
            <td class="green">116</td>
            <td>        (false, treeCopy.DefDef(t, dd.mods, dd.name, dd.tparams, dd.vparamss, dd.tpt, recurse(dd.rhs)))
</td>
          </tr><tr>
            <td class="black">117</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">118</td>
            <td>      case vd: ValDef if (vd.symbol.isParamAccessor) =&gt; {
</td>
          </tr><tr>
            <td class="green">119</td>
            <td>        (false, t)
</td>
          </tr><tr>
            <td class="black">120</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">121</td>
            <td>      case vd: ValDef =&gt; {
</td>
          </tr><tr>
            <td class="green">122</td>
            <td>        (false, treeCopy.ValDef(t, vd.mods, vd.name, vd.tpt, recurse(vd.rhs)))
</td>
          </tr><tr>
            <td class="black">123</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">124</td>
            <td>      case Template(parents, self, body) =&gt; {
</td>
          </tr><tr>
            <td class="green">125</td>
            <td>        (false, treeCopy.Template(t, parents, self, instrument(super.transformStats(body, t.symbol))))
</td>
          </tr><tr>
            <td class="black">126</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">127</td>
            <td>      case If(cond, thenp, elsep) =&gt; {
</td>
          </tr><tr>
            <td class="green">128</td>
            <td>        (false, treeCopy.If(t, recurse(cond), recurse(thenp), recurse(elsep)))
</td>
          </tr><tr>
            <td class="black">129</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">130</td>
            <td>      case Function(vparams, body) =&gt; {
</td>
          </tr><tr>
            <td class="green">131</td>
            <td>        (false, treeCopy.Function(t, vparams, recurse(body)))
</td>
          </tr><tr>
            <td class="black">132</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">133</td>
            <td>      case Match(selector, cases) =&gt; {
</td>
          </tr><tr>
            <td class="green">134</td>
            <td>        (false, treeCopy.Match(t, recurse(selector), super.transformCaseDefs(cases)))
</td>
          </tr><tr>
            <td class="black">135</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">136</td>
            <td>      case CaseDef(pat, guard, body) =&gt; {
</td>
          </tr><tr>
            <td class="green">137</td>
            <td>        (false, treeCopy.CaseDef(t, pat, recurse(guard), recurse(body)))
</td>
          </tr><tr>
            <td class="black">138</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">139</td>
            <td>      case Try(block, catches, finalizer) =&gt; {
</td>
          </tr><tr>
            <td class="green">140</td>
            <td>        (false, treeCopy.Try(t, recurse(block), super.transformCaseDefs(catches), recurse(finalizer)))
</td>
          </tr><tr>
            <td class="black">141</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">142</td>
            <td>      case LabelDef(name1, List(), i @ If(_, b @ Block(_, Apply(Ident(name2), List())), Literal(Constant(())))) if (name1 == name2 &amp;&amp; name1.startsWith(&quot;while&quot;)) =&gt; {
</td>
          </tr><tr>
            <td class="green">143</td>
            <td>        val newBlock = treeCopy.Block(b, instrument(super.transformStats(b.stats, currentOwner)), b.expr)
</td>
          </tr><tr>
            <td class="green">144</td>
            <td>        val newIf = treeCopy.If(i, recurse(i.cond), newBlock, i.elsep)
</td>
          </tr><tr>
            <td class="green">145</td>
            <td>        (false, treeCopy.LabelDef(t, name1, List(), newIf))
</td>
          </tr><tr>
            <td class="black">146</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">147</td>
            <td>      case LabelDef(name1, List(), b @ Block(stats, i @ If(cond, Apply(Ident(name2), List()), Literal(Constant(()))))) if (name1 == name2 &amp;&amp; name1.startsWith(&quot;doWhile&quot;)) =&gt; {
</td>
          </tr><tr>
            <td class="green">148</td>
            <td>        val newIf = treeCopy.If(i, recurse(i.cond), i.thenp, i.elsep)
</td>
          </tr><tr>
            <td class="green">149</td>
            <td>        val newBlock = treeCopy.Block(b, instrument(super.transformStats(b.stats, currentOwner)), newIf)
</td>
          </tr><tr>
            <td class="green">150</td>
            <td>        (false, treeCopy.LabelDef(t, name1, List(), newBlock))
</td>
          </tr><tr>
            <td class="black">151</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">152</td>
            <td>      case b: Block =&gt; {
</td>
          </tr><tr>
            <td class="green">153</td>
            <td>        val originalStats = instrument(super.transformStats(b.stats, currentOwner))
</td>
          </tr><tr>
            <td class="green">154</td>
            <td>        val stats = originalStats ::: (if (shouldInstrument(b.expr)) List(coverageCall(b.expr)) else List())
</td>
          </tr><tr>
            <td class="green">155</td>
            <td>        val expr = transform(b.expr)
</td>
          </tr><tr>
            <td class="green">156</td>
            <td>        (false, treeCopy.Block(b, stats, expr))
</td>
          </tr><tr>
            <td class="black">157</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">158</td>
            <td>      case _ =&gt; (true, t)
</td>
          </tr><tr>
            <td class="black">159</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">160</td>
            <td>
</td>
          </tr><tr>
            <td class="green">161</td>
            <td>    def recurse(t: Tree) = if (shouldInstrument(t)) instrument(transform(t)) else transform(t)
</td>
          </tr><tr>
            <td class="black">162</td>
            <td>
</td>
          </tr><tr>
            <td class="green">163</td>
            <td>    def shouldInstrument(t: Tree) = t match {
</td>
          </tr><tr>
            <td class="green">164</td>
            <td>      case _:ClassDef =&gt; false
</td>
          </tr><tr>
            <td class="red">165</td>
            <td>      case _:Template =&gt; <span class="non">false
</span></td>
          </tr><tr>
            <td class="green">166</td>
            <td>      case _:TypeDef =&gt; false
</td>
          </tr><tr>
            <td class="green">167</td>
            <td>      case _:DefDef =&gt; false
</td>
          </tr><tr>
            <td class="green">168</td>
            <td>      case _:ValDef =&gt; false
</td>
          </tr><tr>
            <td class="green">169</td>
            <td>      case _:Block =&gt; false
</td>
          </tr><tr>
            <td class="green">170</td>
            <td>      case _:If =&gt; false
</td>
          </tr><tr>
            <td class="green">171</td>
            <td>      case _:Function =&gt; false
</td>
          </tr><tr>
            <td class="green">172</td>
            <td>      case _:Match =&gt; false
</td>
          </tr><tr>
            <td class="red">173</td>
            <td>      case _:CaseDef =&gt; <span class="non">false
</span></td>
          </tr><tr>
            <td class="green">174</td>
            <td>      case _:Try =&gt; false
</td>
          </tr><tr>
            <td class="green">175</td>
            <td>      case _:LabelDef =&gt; false
</td>
          </tr><tr>
            <td class="green">176</td>
            <td>      case EmptyTree =&gt; false
</td>
          </tr><tr>
            <td class="green">177</td>
            <td>      case Literal(Constant(())) =&gt; false
</td>
          </tr><tr>
            <td class="green">178</td>
            <td>      case _ =&gt; true
</td>
          </tr><tr>
            <td class="black">179</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">180</td>
            <td>
</td>
          </tr><tr>
            <td class="green">181</td>
            <td>    def instrument(t: Tree): Tree = treeCopy.Block(t, List(coverageCall(t)), t)
</td>
          </tr><tr>
            <td class="black">182</td>
            <td>
</td>
          </tr><tr>
            <td class="green">183</td>
            <td>    def instrument(statements: List[Tree]): List[Tree] = statements.foldLeft(List[Tree]()) { (list, stat) =&gt;
</td>
          </tr><tr>
            <td class="green">184</td>
            <td>      if (shouldInstrument(stat)) list ::: List(coverageCall(stat), stat) else list ::: List(stat)
</td>
          </tr><tr>
            <td class="black">185</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">186</td>
            <td>
</td>
          </tr><tr>
            <td class="black">187</td>
            <td>    def instrumentConstructor(primary: Boolean, dd: DefDef) = {
</td>
          </tr><tr>
            <td class="green">188</td>
            <td>      val block @ Block(list, expr @ Literal(_)) = dd.rhs
</td>
          </tr><tr>
            <td class="black">189</td>
            <td>
</td>
          </tr><tr>
            <td class="black">190</td>
            <td>      def instrumentConstructorStatements(list: List[Tree], acc: List[Tree]): List[Tree] = {
</td>
          </tr><tr>
            <td class="green">191</td>
            <td>        list match {
</td>
          </tr><tr>
            <td class="green">192</td>
            <td>          case Nil =&gt; acc.reverse
</td>
          </tr><tr>
            <td class="green">193</td>
            <td>          case head :: tail =&gt; head match {
</td>
          </tr><tr>
            <td class="black">194</td>
            <td>            case vd: ValDef =&gt; {
</td>
          </tr><tr>
            <td class="green">195</td>
            <td>              instrumentConstructorStatements(tail, recurse(vd) :: acc)
</td>
          </tr><tr>
            <td class="black">196</td>
            <td>            }
</td>
          </tr><tr>
            <td class="green">197</td>
            <td>            case a: Apply if !acc.exists(_.isInstanceOf[Apply]) =&gt; {
</td>
          </tr><tr>
            <td class="green">198</td>
            <td>              val applyInstrumentation = if (primary) coverageCall(block) else coverageCall(a)
</td>
          </tr><tr>
            <td class="green">199</td>
            <td>              val newApply = treeCopy.Apply(a, a.fun, super.transformTrees(a.args))
</td>
          </tr><tr>
            <td class="green">200</td>
            <td>              instrumentConstructorStatements(tail, applyInstrumentation :: newApply :: acc)
</td>
          </tr><tr>
            <td class="black">201</td>
            <td>            }
</td>
          </tr><tr>
            <td class="black">202</td>
            <td>            case _ =&gt; {
</td>
          </tr><tr>
            <td class="green">203</td>
            <td>              val newTail = instrument(super.transformStats(list, currentOwner))
</td>
          </tr><tr>
            <td class="green">204</td>
            <td>              acc.reverse ::: newTail
</td>
          </tr><tr>
            <td class="black">205</td>
            <td>            }
</td>
          </tr><tr>
            <td class="black">206</td>
            <td>          }
</td>
          </tr><tr>
            <td class="black">207</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">208</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">209</td>
            <td>
</td>
          </tr><tr>
            <td class="green">210</td>
            <td>      val newStats = instrumentConstructorStatements(list, List[Tree]())
</td>
          </tr><tr>
            <td class="green">211</td>
            <td>      val newRhs = treeCopy.Block(block, newStats, expr)
</td>
          </tr><tr>
            <td class="green">212</td>
            <td>      treeCopy.DefDef(dd, dd.mods, dd.name, dd.tparams, dd.vparamss, dd.tpt, newRhs)
</td>
          </tr><tr>
            <td class="black">213</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">214</td>
            <td>
</td>
          </tr><tr>
            <td class="black">215</td>
            <td>    private def coverageCall(tree: Tree) = {
</td>
          </tr><tr>
            <td class="green">216</td>
            <td>      val id = newId
</td>
          </tr><tr>
            <td class="green">217</td>
            <td>      data = CoveredBlock(id, createName(currentOwner, tree), minOffset(tree), false) :: data
</td>
          </tr><tr>
            <td class="green">218</td>
            <td>      fitIntoTree(tree, rawCoverageCall(id))
</td>
          </tr><tr>
            <td class="black">219</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">220</td>
            <td>
</td>
          </tr><tr>
            <td class="black">221</td>
            <td>    private def fitIntoTree(orig: Tree, newTree: Tree) = {
</td>
          </tr><tr>
            <td class="green">222</td>
            <td>      localTyper.typed(atPos(orig.pos)(newTree))
</td>
          </tr><tr>
            <td class="black">223</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">224</td>
            <td>
</td>
          </tr><tr>
            <td class="black">225</td>
            <td>    private def rawCoverageCall(id: String) = {
</td>
          </tr><tr>
            <td class="green">226</td>
            <td>      val fun = Select( Select( Select(Ident(&quot;reaktor&quot;), newTermName(&quot;scct&quot;) ), newTermName(&quot;Coverage&quot;) ), newTermName(&quot;invoked&quot;) )
</td>
          </tr><tr>
            <td class="green">227</td>
            <td>      Apply(fun, List(Literal(id)))
</td>
          </tr><tr>
            <td class="black">228</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">229</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">230</td>
            <td>
</td>
          </tr><tr>
            <td class="black">231</td>
            <td>  private def createName(owner: Symbol, tree: Tree) = {
</td>
          </tr><tr>
            <td class="green">232</td>
            <td>    val src = tree.pos.source.file match {
</td>
          </tr><tr>
            <td class="red">233</td>
            <td>      case null =&gt; <span class="non">&quot;&lt;no file&gt;&quot;
</span></td>
          </tr><tr>
            <td class="green">234</td>
            <td>      case f =&gt; IO.relativePath(f.file, opts.baseDir)
</td>
          </tr><tr>
            <td class="black">235</td>
            <td>    }
</td>
          </tr><tr>
            <td class="green">236</td>
            <td>    Name(src, classType(owner), packageName(tree, owner), className(tree, owner), opts.projectId)
</td>
          </tr><tr>
            <td class="black">237</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">238</td>
            <td>
</td>
          </tr><tr>
            <td class="black">239</td>
            <td>  def className(tree: Tree, owner: Symbol): String = {
</td>
          </tr><tr>
            <td class="black">240</td>
            <td>    def fromSymbol(s: Symbol): String = {
</td>
          </tr><tr>
            <td class="green">241</td>
            <td>      def parent = s.owner.enclClass
</td>
          </tr><tr>
            <td class="yellow">242</td>
            <td>      if (s.isPackageClass) <span class="non">&quot;&quot;
</span></td>
          </tr><tr>
            <td class="green">243</td>
            <td>        else if (s.isAnonymousClass) fromSymbol(parent)
</td>
          </tr><tr>
            <td class="green">244</td>
            <td>        else if (s.isPackageObjectClass) &quot;&quot;
</td>
          </tr><tr>
            <td class="green">245</td>
            <td>        else if (parent.isPackageClass || parent.isPackageObjectClass) s.simpleName.toString
</td>
          </tr><tr>
            <td class="green">246</td>
            <td>        else fromSymbol(parent) + &quot;.&quot; + s.simpleName
</td>
          </tr><tr>
            <td class="black">247</td>
            <td>    }
</td>
          </tr><tr>
            <td class="green">248</td>
            <td>    tree match {
</td>
          </tr><tr>
            <td class="red">249</td>
            <td>      case cd: ClassDef =&gt; <span class="non">fromSymbol(cd.symbol)
</span></td>
          </tr><tr>
            <td class="green">250</td>
            <td>      case _ =&gt; fromSymbol(owner.enclClass)
</td>
          </tr><tr>
            <td class="black">251</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">252</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">253</td>
            <td>
</td>
          </tr><tr>
            <td class="green">254</td>
            <td>  def packageName(tree: Tree, owner: Symbol): String = tree match {
</td>
          </tr><tr>
            <td class="red">255</td>
            <td>    case pd: PackageDef if <span class="non">pd.symbol.isEmptyPackage =&gt; &quot;&lt;root&gt;&quot;
</span></td>
          </tr><tr>
            <td class="red">256</td>
            <td>    case pd: PackageDef =&gt; <span class="non">pd.symbol.fullName.toString
</span></td>
          </tr><tr>
            <td class="yellow">257</td>
            <td>    case _ =&gt; if (owner.isEmptyPackageClass || owner.isEmptyPackage) <span class="non">&quot;&lt;root&gt;&quot;
</span></td>
          </tr><tr>
            <td class="yellow">258</td>
            <td>                else if (owner.isPackage || owner.isPackageClass) <span class="non">owner.fullName.toString
</span></td>
          </tr><tr>
            <td class="yellow">259</td>
            <td>                else if (owner.toplevelClass == NoSymbol) <span class="non">&quot;&lt;root&gt;&quot;
</span></td>
          </tr><tr>
            <td class="green">260</td>
            <td>                else if (owner.toplevelClass.owner.isEmptyPackageClass) &quot;&lt;root&gt;&quot;
</td>
          </tr><tr>
            <td class="green">261</td>
            <td>                else owner.toplevelClass.owner.fullName.toString
</td>
          </tr><tr>
            <td class="black">262</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">263</td>
            <td>
</td>
          </tr><tr>
            <td class="black">264</td>
            <td>
</td>
          </tr><tr>
            <td class="black">265</td>
            <td>  def classType(s: Symbol) = {
</td>
          </tr><tr>
            <td class="yellow">266</td>
            <td>    if (s.isEffectiveRoot) <span class="non">ClassTypes.Root
</span></td>
          </tr><tr>
            <td class="green">267</td>
            <td>      else if (s.isPackageObjectClass) ClassTypes.Package
</td>
          </tr><tr>
            <td class="green">268</td>
            <td>      else if (s.isModule || s.isModuleClass) ClassTypes.Object
</td>
          </tr><tr>
            <td class="green">269</td>
            <td>      else if (s.isTrait) ClassTypes.Trait
</td>
          </tr><tr>
            <td class="green">270</td>
            <td>      else ClassTypes.Class
</td>
          </tr><tr>
            <td class="black">271</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">272</td>
            <td>
</td>
          </tr><tr>
            <td class="black">273</td>
            <td>
</td>
          </tr><tr>
            <td class="green">274</td>
            <td>  def minOffset(t: Tree) = new MinimumOffsetFinder().offsetFor(t)
</td>
          </tr><tr>
            <td class="black">275</td>
            <td>
</td>
          </tr><tr>
            <td class="green">276</td>
            <td><a id="Class_reaktor_scct_ScctTransformComponent_MinimumOffsetFinder"></a>  class MinimumOffsetFinder extends Traverser {
</td>
          </tr><tr>
            <td class="green">277</td>
            <td>    var min = Integer.MAX_VALUE
</td>
          </tr><tr>
            <td class="black">278</td>
            <td>    override def traverse(t: Tree) {
</td>
          </tr><tr>
            <td class="green">279</td>
            <td>      if (t.pos.isDefined) {
</td>
          </tr><tr>
            <td class="green">280</td>
            <td>        val curr = t.pos.startOrPoint
</td>
          </tr><tr>
            <td class="green">281</td>
            <td>        if (curr &lt; min) min = curr
</td>
          </tr><tr>
            <td class="black">282</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">283</td>
            <td>      super.traverse(t)
</td>
          </tr><tr>
            <td class="black">284</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">285</td>
            <td>
</td>
          </tr><tr>
            <td class="black">286</td>
            <td>    def offsetFor(t: Tree): Int = {
</td>
          </tr><tr>
            <td class="green">287</td>
            <td>      min = Integer.MAX_VALUE
</td>
          </tr><tr>
            <td class="green">288</td>
            <td>      super.apply(t)
</td>
          </tr><tr>
            <td class="green">289</td>
            <td>      min
</td>
          </tr><tr>
            <td class="black">290</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">291</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">292</td>
            <td>
</td>
          </tr><tr>
            <td class="black">293</td>
            <td>
</td>
          </tr><tr>
            <td class="green">294</td>
            <td>  def registerClasses(unit: CompilationUnit) = new ClassRegisterer().apply(unit.body)
</td>
          </tr><tr>
            <td class="black">295</td>
            <td>
</td>
          </tr><tr>
            <td class="green">296</td>
            <td><a id="Class_reaktor_scct_ScctTransformComponent_ClassRegisterer"></a>  class ClassRegisterer extends Traverser {
</td>
          </tr><tr>
            <td class="black">297</td>
            <td>    override def traverse(tree: Tree) = {
</td>
          </tr><tr>
            <td class="green">298</td>
            <td>      tree match {
</td>
          </tr><tr>
            <td class="green">299</td>
            <td>        case t: Template if (!t.symbol.owner.isSynthetic) =&gt; {
</td>
          </tr><tr>
            <td class="green">300</td>
            <td>          data = CoveredBlock(newId, createName(t.symbol.owner, tree), minOffset(tree), true) :: data
</td>
          </tr><tr>
            <td class="black">301</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">302</td>
            <td>        case _ =&gt;
</td>
          </tr><tr>
            <td class="black">303</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">304</td>
            <td>      super.traverse(tree)
</td>
          </tr><tr>
            <td class="black">305</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">306</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">307</td>
            <td>}
</td>
          </tr></tbody></table>