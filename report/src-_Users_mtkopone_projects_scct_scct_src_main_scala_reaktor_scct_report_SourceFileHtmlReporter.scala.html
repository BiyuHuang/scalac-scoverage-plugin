<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <link rel="stylesheet" type="text/css" href="style.css" />
    
  </head>
  <body><table><tbody><tr>
      <td class="barContainerLeft"><a href="#">reaktor/scct/report/<span class="header">SourceFileHtmlReporter.scala</span></a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">23 %</div>
        <div class="greenBar" style="width:46px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct_scct_src_main_scala_reaktor_scct_report_SourceFileHtmlReporter.scala.html#Class_reaktor_scct_report_SourceFileHtmlReporter"><img src="class.png"></img>SourceFileHtmlReporter</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">24 %</div>
        <div class="greenBar" style="width:48px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct_scct_src_main_scala_reaktor_scct_report_SourceFileHtmlReporter.scala.html#Object_reaktor_scct_report_SourceFileHtmlReporter"><img src="object.png"></img>SourceFileHtmlReporter</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">0 %</div>
        <div class="greenBar" style="width:0px;">&nbsp;</div>
      </div>
    </div></td>
    </tr></tbody></table><table class="source"><tbody><tr >
            <td class="black">1</td>
            <td>package reaktor.scct.report
</td>
          </tr><tr >
            <td class="black">2</td>
            <td>
</td>
          </tr><tr >
            <td class="black">3</td>
            <td>import xml.{NodeSeq, Text}
</td>
          </tr><tr >
            <td class="black">4</td>
            <td>import reaktor.scct.{ClassTypes, Name, CoveredBlock}
</td>
          </tr><tr >
            <td class="black">5</td>
            <td>
</td>
          </tr><tr id="Object_reaktor_scct_report_SourceFileHtmlReporter">
            <td class="black">6</td>
            <td>object SourceFileHtmlReporter {
</td>
          </tr><tr >
            <td class="black">7</td>
            <td>  def report(sourceFile: String, data: CoverageData) =
</td>
          </tr><tr >
            <td class="red">8</td>
            <td>    <span class="non">new SourceFileHtmlReporter(sourceFile, data, new SourceLoader).report
</span></td>
          </tr><tr >
            <td class="black">9</td>
            <td>}
</td>
          </tr><tr >
            <td class="black">10</td>
            <td>
</td>
          </tr><tr id="Class_reaktor_scct_report_SourceFileHtmlReporter">
            <td class="green">11</td>
            <td>class SourceFileHtmlReporter(sourceFile: String, data: CoverageData, sourceLoader: SourceLoader) {
</td>
          </tr><tr >
            <td class="black">12</td>
            <td>  import HtmlReporter._
</td>
          </tr><tr >
            <td class="black">13</td>
            <td>
</td>
          </tr><tr >
            <td class="green">14</td>
            <td>  val sourceReferenceDir = System.getProperty(&quot;scct.src.reference.dir&quot;, &quot;&quot;)
</td>
          </tr><tr >
            <td class="black">15</td>
            <td>
</td>
          </tr><tr >
            <td class="black">16</td>
            <td>  def report = {
</td>
          </tr><tr >
            <td class="red">17</td>
            <td>    <span class="non">sourceFileHeader ++ sourceFileContent
</span></td>
          </tr><tr >
            <td class="black">18</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">19</td>
            <td>
</td>
          </tr><tr >
            <td class="black">20</td>
            <td>  def sourceFileHeader = {
</td>
          </tr><tr >
            <td class="red">21</td>
            <td>    val header = <span class="non">itemRow(formatSourceFileName(sourceFile), data.percentage, &quot;#&quot;)
</span></td>
          </tr><tr >
            <td class="red">22</td>
            <td>    val classRows = <span class="non">classItemRows(data)
</span></td>
          </tr><tr >
            <td class="red">23</td>
            <td>    <span class="non">table(header, classRows)
</span></td>
          </tr><tr >
            <td class="black">24</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">25</td>
            <td>
</td>
          </tr><tr >
            <td class="black">26</td>
            <td>  def formatSourceFileName(sourceFile: String) = {
</td>
          </tr><tr >
            <td class="red">27</td>
            <td>    val name = <span class="non">Some(sourceFile).map(_.replaceFirst(sourceReferenceDir, &quot;&quot;)).map(s =&gt; if (s.startsWith(&quot;/&quot;)) s.substring(1) else s).get
</span></td>
          </tr><tr >
            <td class="red">28</td>
            <td>    <span class="non">name.lastIndexOf('/') match {
</span></td>
          </tr><tr >
            <td class="red">29</td>
            <td>      case -1 =&gt; &lt;<span class="non">span class=&quot;header&quot;&gt;{ name }&lt;/span&gt;
</span></td>
          </tr><tr >
            <td class="red">30</td>
            <td>      case idx =&gt; <span class="non">Text(name.substring(0, idx+1)) ++ &lt;span class=&quot;header&quot;&gt;{ name.substring(idx+1) }&lt;/span&gt;
</span></td>
          </tr><tr >
            <td class="black">31</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">32</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">33</td>
            <td>  def sourceFileContent =
</td>
          </tr><tr >
            <td class="red">34</td>
            <td>    &lt;<span class="non">table class=&quot;source&quot;&gt;&lt;tbody&gt;{ sourceLines(sourceFile, data) }&lt;/tbody&gt;&lt;/table&gt;
</span></td>
          </tr><tr >
            <td class="black">35</td>
            <td>
</td>
          </tr><tr >
            <td class="black">36</td>
            <td>  def sourceLines(sourceFile: String, data: CoverageData): NodeSeq = {
</td>
          </tr><tr >
            <td class="red">37</td>
            <td>    <span class="non">sourceLines(1, 0, sourceLoader.linesFor(sourceFile), data.blocks, Name(&quot;&quot;, ClassTypes.Root, &quot;&quot;, &quot;&quot;), NodeSeq.Empty)
</span></td>
          </tr><tr >
            <td class="black">38</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">39</td>
            <td>
</td>
          </tr><tr >
            <td class="black">40</td>
            <td>  def sourceLines(lineNum: Int, offset: Int, lines: List[String], blocks: List[CoveredBlock], currentName: Name, acc: NodeSeq): NodeSeq = {
</td>
          </tr><tr >
            <td class="black">41</td>
            <td>    lines match {
</td>
          </tr><tr >
            <td class="red">42</td>
            <td>      case Nil =&gt; <span class="non">acc
</span></td>
          </tr><tr >
            <td class="black">43</td>
            <td>      case line :: tail =&gt; {
</td>
          </tr><tr >
            <td class="red">44</td>
            <td>        val maxOffset = <span class="non">offset + line.length
</span></td>
          </tr><tr >
            <td class="red">45</td>
            <td>        val (<span class="non">currBlocks, nextBlocks) = blocks.partition(_.offset &lt; maxOffset)
</span></td>
          </tr><tr >
            <td class="red">46</td>
            <td>        val lineHtml = <span class="non">formatLine(line, offset, currBlocks.filter(!_.placeHolder))
</span></td>
          </tr><tr >
            <td class="red">47</td>
            <td>        val newName = <span class="non">currBlocks.firstOption.map(_.name).getOrElse(currentName)
</span></td>
          </tr><tr >
            <td class="red">48</td>
            <td>        val classId = if (currentName != newName) <span class="non">Some(Text(toHtmlId(newName))) else None
</span></td>
          </tr><tr >
            <td class="black">49</td>
            <td>        val rowHtml =
</td>
          </tr><tr >
            <td class="red">50</td>
            <td>          &lt;<span class="non">tr id={classId}&gt;
</span></td>
          </tr><tr >
            <td class="red">51</td>
            <td>            &lt;<span class="non">td class={chooseColor(currBlocks.filter(!_.placeHolder))}&gt;{lineNum}&lt;/td&gt;
</span></td>
          </tr><tr >
            <td class="red">52</td>
            <td>            &lt;<span class="non">td&gt;{ lineHtml }&lt;/td&gt;
</span></td>
          </tr><tr >
            <td class="black">53</td>
            <td>          &lt;/tr&gt;
</td>
          </tr><tr >
            <td class="red">54</td>
            <td>        <span class="non">sourceLines(lineNum + 1, maxOffset, tail, nextBlocks, newName, acc ++ rowHtml)
</span></td>
          </tr><tr >
            <td class="black">55</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">56</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">57</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">58</td>
            <td>
</td>
          </tr><tr >
            <td class="black">59</td>
            <td>  private def chooseColor(metadatas: List[CoveredBlock]) = {
</td>
          </tr><tr >
            <td class="black">60</td>
            <td>    metadatas.length match {
</td>
          </tr><tr >
            <td class="red">61</td>
            <td>      case 0 =&gt; <span class="non">&quot;black&quot;
</span></td>
          </tr><tr >
            <td class="black">62</td>
            <td>      case _ =&gt; {
</td>
          </tr><tr >
            <td class="red">63</td>
            <td>        val hits = <span class="non">metadatas.filter(_.count &gt; 0).size
</span></td>
          </tr><tr >
            <td class="red">64</td>
            <td>        <span class="non">if (hits == 0) &quot;red&quot; else if (hits == metadatas.length) &quot;green&quot; else &quot;yellow&quot;
</span></td>
          </tr><tr >
            <td class="black">65</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">66</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">67</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">68</td>
            <td>
</td>
          </tr><tr >
            <td class="black">69</td>
            <td>  def formatLine(line: String, offset: Int, blocks: List[CoveredBlock]): NodeSeq =
</td>
          </tr><tr >
            <td class="green">70</td>
            <td>    formatLine(List[Char](), line.toList, offset, true, blocks, NodeSeq.Empty)
</td>
          </tr><tr >
            <td class="black">71</td>
            <td>
</td>
          </tr><tr >
            <td class="black">72</td>
            <td>  private def formatLine(prevChars: List[Char], line: List[Char], offset: Int, isCovered: Boolean, blocks: List[CoveredBlock], acc: NodeSeq): NodeSeq = {
</td>
          </tr><tr >
            <td class="black">73</td>
            <td>    blocks match {
</td>
          </tr><tr >
            <td class="green">74</td>
            <td>      case Nil =&gt; acc ++ formatLinePart(prevChars ::: line, isCovered)
</td>
          </tr><tr >
            <td class="black">75</td>
            <td>      case block :: tail =&gt; {
</td>
          </tr><tr >
            <td class="green">76</td>
            <td>        val (currChars, nextChars) = line.splitAt(block.offset - offset)
</td>
          </tr><tr >
            <td class="green">77</td>
            <td>        if (isCovered == block.count &gt; 0) {
</td>
          </tr><tr >
            <td class="green">78</td>
            <td>          formatLine(prevChars ::: currChars, nextChars, block.offset, isCovered, tail, acc)
</td>
          </tr><tr >
            <td class="black">79</td>
            <td>        } else {
</td>
          </tr><tr >
            <td class="green">80</td>
            <td>          val part = formatLinePart(prevChars ::: currChars, isCovered)
</td>
          </tr><tr >
            <td class="green">81</td>
            <td>          formatLine(List[Char](), nextChars, block.offset, block.count &gt; 0, tail, acc ++ part)
</td>
          </tr><tr >
            <td class="black">82</td>
            <td>        }
</td>
          </tr><tr >
            <td class="black">83</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">84</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">85</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">86</td>
            <td>
</td>
          </tr><tr >
            <td class="black">87</td>
            <td>  private def formatLinePart(part: List[Char], isCovered: Boolean) = {
</td>
          </tr><tr >
            <td class="green">88</td>
            <td>    val nbsp = &quot;\u00A0\u00A0&quot;
</td>
          </tr><tr >
            <td class="green">89</td>
            <td>    val tabbed = part.mkString.replaceAll(&quot;\t&quot;, nbsp).replaceAll(&quot;  &quot;, nbsp)
</td>
          </tr><tr >
            <td class="green">90</td>
            <td>    if (isCovered) Text(tabbed) else &lt;span class=&quot;non&quot;&gt;{ tabbed }&lt;/span&gt;
</td>
          </tr><tr >
            <td class="black">91</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">92</td>
            <td>
</td>
          </tr><tr >
            <td class="black">93</td>
            <td>}</td>
          </tr></tbody></table></body>
</html>