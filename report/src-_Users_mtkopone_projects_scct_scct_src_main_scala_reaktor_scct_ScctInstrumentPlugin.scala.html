<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <link rel="stylesheet" type="text/css" href="style.css" />
    
  </head>
  <body><table><tbody><tr>
      <td class="barContainerLeft"><a href="#">reaktor/scct/<span class="header">ScctInstrumentPlugin.scala</span></a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">93 %</div>
        <div class="greenBar" style="width:186px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct_scct_src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctInstrumentPlugin"><img src="class.png"></img>ScctInstrumentPlugin</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct_scct_src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent"><img src="class.png"></img>ScctTransformComponent</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">84 %</div>
        <div class="greenBar" style="width:168px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct_scct_src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent_MinimumOffsetFinder"><img src="class.png"></img>ScctTransformComponent.MinimumOffsetFinder</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct_scct_src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent_ScctTransformer"><img src="class.png"></img>ScctTransformComponent.ScctTransformer</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">93 %</div>
        <div class="greenBar" style="width:186px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct_scct_src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent_ScctTransformer_TreeState"><img src="class.png"></img>ScctTransformComponent.ScctTransformer.TreeState</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr></tbody></table><table class="source"><tbody><tr >
            <td class="black">1</td>
            <td>package reaktor.scct
</td>
          </tr><tr >
            <td class="black">2</td>
            <td>
</td>
          </tr><tr >
            <td class="black">3</td>
            <td>import tools.nsc.plugins.{PluginComponent, Plugin}
</td>
          </tr><tr >
            <td class="black">4</td>
            <td>import tools.nsc.{Phase, Global}
</td>
          </tr><tr >
            <td class="black">5</td>
            <td>import java.io.File
</td>
          </tr><tr >
            <td class="black">6</td>
            <td>import tools.nsc.transform.{Transform, TypingTransformers}
</td>
          </tr><tr >
            <td class="black">7</td>
            <td>import tools.nsc.symtab.Flags
</td>
          </tr><tr >
            <td class="black">8</td>
            <td>
</td>
          </tr><tr id="Class_reaktor_scct_ScctInstrumentPlugin">
            <td class="green">9</td>
            <td>class ScctInstrumentPlugin(val global: Global) extends Plugin {
</td>
          </tr><tr >
            <td class="green">10</td>
            <td>  val name = &quot;scct&quot;
</td>
          </tr><tr >
            <td class="green">11</td>
            <td>  val description = &quot;Scala code coverage instrumentation plugin.&quot;
</td>
          </tr><tr >
            <td class="green">12</td>
            <td>  val runsAfter = &quot;refchecks&quot;
</td>
          </tr><tr >
            <td class="green">13</td>
            <td>  val components = List(new ScctTransformComponent(global))
</td>
          </tr><tr >
            <td class="black">14</td>
            <td>}
</td>
          </tr><tr >
            <td class="black">15</td>
            <td>
</td>
          </tr><tr id="Class_reaktor_scct_ScctTransformComponent">
            <td class="green">16</td>
            <td>class ScctTransformComponent(val global: Global) extends PluginComponent with TypingTransformers with Transform {
</td>
          </tr><tr >
            <td class="black">17</td>
            <td>  import global._
</td>
          </tr><tr >
            <td class="black">18</td>
            <td>  import posAssigner.atPos
</td>
          </tr><tr >
            <td class="black">19</td>
            <td>
</td>
          </tr><tr >
            <td class="green">20</td>
            <td>  val phaseName = &quot;ScctTransformComponent&quot;
</td>
          </tr><tr >
            <td class="green">21</td>
            <td>  val runsAfter = &quot;refchecks&quot;
</td>
          </tr><tr >
            <td class="green">22</td>
            <td>  lazy val coverageFile = new File(global.settings.outdir.value, &quot;coverage.data&quot;)
</td>
          </tr><tr >
            <td class="black">23</td>
            <td>
</td>
          </tr><tr >
            <td class="green">24</td>
            <td>  var saveData = true
</td>
          </tr><tr >
            <td class="green">25</td>
            <td>  var counter = 0L
</td>
          </tr><tr >
            <td class="green">26</td>
            <td>  var data: List[CoveredBlock] = Nil
</td>
          </tr><tr >
            <td class="black">27</td>
            <td>
</td>
          </tr><tr >
            <td class="green">28</td>
            <td>  def newTransformer(unit: CompilationUnit) = new ScctTransformer(unit)
</td>
          </tr><tr >
            <td class="black">29</td>
            <td>
</td>
          </tr><tr >
            <td class="green">30</td>
            <td>  override def newPhase(prev: scala.tools.nsc.Phase): StdPhase = new Phase(prev) {
</td>
          </tr><tr >
            <td class="black">31</td>
            <td>    override def run {
</td>
          </tr><tr >
            <td class="green">32</td>
            <td>      clearMetadata
</td>
          </tr><tr >
            <td class="green">33</td>
            <td>      super.run
</td>
          </tr><tr >
            <td class="green">34</td>
            <td>      saveMetadata
</td>
          </tr><tr >
            <td class="black">35</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">36</td>
            <td>    private def clearMetadata {
</td>
          </tr><tr >
            <td class="red">37</td>
            <td>      if (coverageFile.exists) <span class="non">coverageFile.delete
</span></td>
          </tr><tr >
            <td class="black">38</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">39</td>
            <td>    private def saveMetadata {
</td>
          </tr><tr >
            <td class="black">40</td>
            <td>      if (saveData) {
</td>
          </tr><tr >
            <td class="red">41</td>
            <td>        <span class="non">println(&quot;scct: Saving coverage data.&quot;)
</span></td>
          </tr><tr >
            <td class="red">42</td>
            <td>        <span class="non">MetadataPickler.toFile(data, coverageFile)
</span></td>
          </tr><tr >
            <td class="black">43</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">44</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">45</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">46</td>
            <td>
</td>
          </tr><tr >
            <td class="green">47</td>
            <td>  def newId = { counter = counter + 1; counter.toString }
</td>
          </tr><tr >
            <td class="black">48</td>
            <td>
</td>
          </tr><tr id="Class_reaktor_scct_ScctTransformComponent_ScctTransformer">
            <td class="green">49</td>
            <td>  class ScctTransformer(unit: CompilationUnit) extends TypingTransformer(unit) {
</td>
          </tr><tr >
            <td class="black">50</td>
            <td>    override def transformUnit(unit: CompilationUnit) {
</td>
          </tr><tr >
            <td class="black">51</td>
            <td>      //treeBrowser.browse(List(unit))
</td>
          </tr><tr >
            <td class="green">52</td>
            <td>      super.transformUnit(unit)
</td>
          </tr><tr >
            <td class="black">53</td>
            <td>      //treeBrowser.browse(List(unit))
</td>
          </tr><tr >
            <td class="green">54</td>
            <td>      maybeDebug(unit)
</td>
          </tr><tr >
            <td class="black">55</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">56</td>
            <td>
</td>
          </tr><tr >
            <td class="black">57</td>
            <td>    private def maybeDebug(unit: CompilationUnit) {
</td>
          </tr><tr >
            <td class="green">58</td>
            <td>      val debug = System.getProperty(&quot;coverage.debug&quot;)
</td>
          </tr><tr >
            <td class="green">59</td>
            <td>      if (debug != null &amp;&amp; (debug.equals(&quot;true&quot;) || unit.source.file.path.endsWith(debug))) {
</td>
          </tr><tr >
            <td class="red">60</td>
            <td>        <span class="non">treeBrowser.browse(List(unit))
</span></td>
          </tr><tr >
            <td class="black">61</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">62</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">63</td>
            <td>
</td>
          </tr><tr id="Class_reaktor_scct_ScctTransformComponent_ScctTransformer_TreeState">
            <td class="green">64</td>
            <td>    case class TreeState(skip: Boolean, isLazyDef: Boolean) {
</td>
          </tr><tr >
            <td class="green">65</td>
            <td>      def toSkip = TreeState(true, isLazyDef)
</td>
          </tr><tr >
            <td class="green">66</td>
            <td>      def toLazyDef = TreeState(skip, true)
</td>
          </tr><tr >
            <td class="black">67</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">68</td>
            <td>
</td>
          </tr><tr id="Class_reaktor_scct_ScctTransformComponent_ScctTransformer">
            <td class="green">69</td>
            <td>    var state = TreeState(false, false)
</td>
          </tr><tr >
            <td class="black">70</td>
            <td>
</td>
          </tr><tr >
            <td class="black">71</td>
            <td>    override def transform(t: Tree): Tree = {
</td>
          </tr><tr >
            <td class="green">72</td>
            <td>      val prevState = state
</td>
          </tr><tr >
            <td class="green">73</td>
            <td>      state = checkTreeState(t)
</td>
          </tr><tr >
            <td class="green">74</td>
            <td>      val tree = super.transform(t)
</td>
          </tr><tr >
            <td class="green">75</td>
            <td>      val result = if (state.skip) placeHolderize(tree) else instrument(tree)
</td>
          </tr><tr >
            <td class="green">76</td>
            <td>      state = prevState
</td>
          </tr><tr >
            <td class="green">77</td>
            <td>      result
</td>
          </tr><tr >
            <td class="black">78</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">79</td>
            <td>
</td>
          </tr><tr >
            <td class="black">80</td>
            <td>    private def placeHolderize(t: Tree) = t match {
</td>
          </tr><tr >
            <td class="green">81</td>
            <td>      case template:Template =&gt; addPlaceHolder(template)
</td>
          </tr><tr >
            <td class="green">82</td>
            <td>      case _ =&gt; t
</td>
          </tr><tr >
            <td class="black">83</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">84</td>
            <td>
</td>
          </tr><tr >
            <td class="black">85</td>
            <td>    private def checkTreeState(t: Tree): TreeState = {
</td>
          </tr><tr >
            <td class="black">86</td>
            <td>      if (!t.hasSymbol) {
</td>
          </tr><tr >
            <td class="green">87</td>
            <td>        state
</td>
          </tr><tr >
            <td class="black">88</td>
            <td>      } else {
</td>
          </tr><tr >
            <td class="green">89</td>
            <td>        val s = t.symbol
</td>
          </tr><tr >
            <td class="green">90</td>
            <td>        def isGenerated = (s.hasFlag(Flags.STABLE) &amp;&amp; !s.hasFlag(Flags.LAZY)) || (s.hasFlag(Flags.SYNTHETIC) &amp;&amp; !s.isAnonymousFunction)
</td>
          </tr><tr >
            <td class="green">91</td>
            <td>        def isGeneratedCaseClassMethod = s.isMethod &amp;&amp; !s.isConstructor &amp;&amp; t.pos.offset == currentClass.pos.offset
</td>
          </tr><tr >
            <td class="green">92</td>
            <td>        def isObjectConstructor = s.isConstructor &amp;&amp; currentClass.isModuleClass
</td>
          </tr><tr >
            <td class="green">93</td>
            <td>        def isNonLazyAccessor = !s.hasFlag(Flags.LAZY) &amp;&amp; s.hasFlag(Flags.ACCESSOR | Flags.PARAMACCESSOR)
</td>
          </tr><tr >
            <td class="black">94</td>
            <td>        def hasSkipAnnotation = t match {
</td>
          </tr><tr >
            <td class="black">95</td>
            <td>          case memberDef: MemberDef =&gt; {
</td>
          </tr><tr >
            <td class="green">96</td>
            <td>            val annots = memberDef.mods.annotations
</td>
          </tr><tr >
            <td class="green">97</td>
            <td>            annots.exists(_.tpe.safeToString == classOf[uncovered].getName)
</td>
          </tr><tr >
            <td class="black">98</td>
            <td>          }
</td>
          </tr><tr >
            <td class="green">99</td>
            <td>          case _ =&gt; false
</td>
          </tr><tr >
            <td class="black">100</td>
            <td>        }
</td>
          </tr><tr >
            <td class="black">101</td>
            <td>        def isLazyDef = t match {
</td>
          </tr><tr >
            <td class="green">102</td>
            <td>          case d:DefDef =&gt; s.isMethod &amp;&amp; s.hasFlag(Flags.LAZY)
</td>
          </tr><tr >
            <td class="green">103</td>
            <td>          case _ =&gt; false
</td>
          </tr><tr >
            <td class="black">104</td>
            <td>        }
</td>
          </tr><tr >
            <td class="black">105</td>
            <td>
</td>
          </tr><tr >
            <td class="green">106</td>
            <td>        if (isGenerated || hasSkipAnnotation || isNonLazyAccessor || isGeneratedCaseClassMethod || isObjectConstructor) {
</td>
          </tr><tr >
            <td class="green">107</td>
            <td>          state.toSkip
</td>
          </tr><tr >
            <td class="black">108</td>
            <td>        } else if (isLazyDef) {
</td>
          </tr><tr >
            <td class="green">109</td>
            <td>          state.toLazyDef
</td>
          </tr><tr >
            <td class="black">110</td>
            <td>        } else {
</td>
          </tr><tr >
            <td class="green">111</td>
            <td>          state
</td>
          </tr><tr >
            <td class="black">112</td>
            <td>        }
</td>
          </tr><tr >
            <td class="black">113</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">114</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">115</td>
            <td>
</td>
          </tr><tr >
            <td class="black">116</td>
            <td>    private def instrument(tree: Tree) = tree match {
</td>
          </tr><tr >
            <td class="black">117</td>
            <td>      // Don't place instrumentation before super call in constructors:
</td>
          </tr><tr >
            <td class="black">118</td>
            <td>      // TODO: check if this is actually a constructor, currently it hits e.g. &quot;try { super.hashCode } catch { ... }&quot;
</td>
          </tr><tr >
            <td class="black">119</td>
            <td>      case Block(stats @ List(Apply(Select(Super(_,_),_), args)), expr @ Literal(Constant(()))) =&gt;
</td>
          </tr><tr >
            <td class="green">120</td>
            <td>        copy.Block(tree, stats ::: List(coverageCall(tree)), expr)
</td>
          </tr><tr >
            <td class="black">121</td>
            <td>
</td>
          </tr><tr >
            <td class="black">122</td>
            <td>      // Skip generated lazy def accessor, since later phases assume { x = &lt;rhs&gt;; x }-tree-structure
</td>
          </tr><tr >
            <td class="black">123</td>
            <td>      case Block(List(a @ Assign(lhs @ Select(_, _), rhs)), expr: Select) if state.isLazyDef =&gt; {
</td>
          </tr><tr >
            <td class="green">124</td>
            <td>        val newAssign = fitIntoTree(a, Assign(lhs, instrumentBody(rhs)))
</td>
          </tr><tr >
            <td class="green">125</td>
            <td>        copy.Block(tree, List(newAssign), expr)
</td>
          </tr><tr >
            <td class="black">126</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">127</td>
            <td>      case Block(List(a @ Assign(lhs @ Ident(_), rhs)), expr: Ident) if state.isLazyDef =&gt; {
</td>
          </tr><tr >
            <td class="green">128</td>
            <td>        val newAssign = fitIntoTree(a, Assign(lhs, instrumentBody(rhs)))
</td>
          </tr><tr >
            <td class="green">129</td>
            <td>        copy.Block(tree, List(newAssign), expr)
</td>
          </tr><tr >
            <td class="black">130</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">131</td>
            <td>      // Skip empty block in e.g. Some(&quot;foo&quot;).map(System.getProperty)
</td>
          </tr><tr >
            <td class="black">132</td>
            <td>      case Block(Nil, Function(_,_)) =&gt;
</td>
          </tr><tr >
            <td class="green">133</td>
            <td>        tree
</td>
          </tr><tr >
            <td class="black">134</td>
            <td>      case Block(stats, expr) =&gt; {
</td>
          </tr><tr >
            <td class="green">135</td>
            <td>        val instrumentedBlock = instrumentBlockStats(stats) ::: instrumentBlockExpr(expr)
</td>
          </tr><tr >
            <td class="green">136</td>
            <td>        copy.Block(tree, instrumentedBlock, expr)
</td>
          </tr><tr >
            <td class="black">137</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">138</td>
            <td>      // Skip generated ifs in do {} while's
</td>
          </tr><tr >
            <td class="black">139</td>
            <td>      case If(cond, thenp @ Apply(i @ Ident(_), Nil), elsep @ Literal(Constant(()))) if i.symbol.isLabel =&gt;
</td>
          </tr><tr >
            <td class="green">140</td>
            <td>        tree
</td>
          </tr><tr >
            <td class="black">141</td>
            <td>      case If(cond, thenp, elsep) =&gt;
</td>
          </tr><tr >
            <td class="green">142</td>
            <td>        copy.If(tree, cond, instrumentBody(thenp), instrumentBody(elsep))
</td>
          </tr><tr >
            <td class="black">143</td>
            <td>      case Function(vparams, body) =&gt;
</td>
          </tr><tr >
            <td class="green">144</td>
            <td>        copy.Function(tree, vparams, instrumentBody(body))
</td>
          </tr><tr >
            <td class="black">145</td>
            <td>      case Try(block, catches, finalizer) =&gt;
</td>
          </tr><tr >
            <td class="green">146</td>
            <td>        copy.Try(tree, instrumentBody(block), catches, instrumentBody(finalizer))
</td>
          </tr><tr >
            <td class="black">147</td>
            <td>      case CaseDef(pat, guard, body) =&gt;
</td>
          </tr><tr >
            <td class="green">148</td>
            <td>        copy.CaseDef(tree, pat, guard, instrumentBody(body))
</td>
          </tr><tr >
            <td class="black">149</td>
            <td>      case ValDef(mods, name, tpt, rhs) =&gt;
</td>
          </tr><tr >
            <td class="green">150</td>
            <td>        copy.ValDef(tree, mods, name, tpt, instrumentBody(rhs))
</td>
          </tr><tr >
            <td class="black">151</td>
            <td>      case DefDef(mods, name, tparams, vparamss, tpt, rhs) =&gt;
</td>
          </tr><tr >
            <td class="green">152</td>
            <td>        copy.DefDef(tree, mods, name, tparams, vparamss, tpt, instrumentBody(rhs))
</td>
          </tr><tr >
            <td class="black">153</td>
            <td>      case template @ Template(parents, self, body) =&gt; {
</td>
          </tr><tr >
            <td class="green">154</td>
            <td>        addPlaceHolder(template)
</td>
          </tr><tr >
            <td class="green">155</td>
            <td>        copy.Template(tree, parents, self, body.map(instrumentBody))
</td>
          </tr><tr >
            <td class="black">156</td>
            <td>      }
</td>
          </tr><tr >
            <td class="green">157</td>
            <td>      case _ =&gt; tree
</td>
          </tr><tr >
            <td class="black">158</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">159</td>
            <td>
</td>
          </tr><tr >
            <td class="black">160</td>
            <td>    private def instrumentBlockExpr(expr: Tree) = expr match {
</td>
          </tr><tr >
            <td class="green">161</td>
            <td>      case Literal(Constant(())) =&gt; Nil
</td>
          </tr><tr >
            <td class="green">162</td>
            <td>      case _:LabelDef =&gt; Nil
</td>
          </tr><tr >
            <td class="green">163</td>
            <td>      case _:Block =&gt; Nil
</td>
          </tr><tr >
            <td class="green">164</td>
            <td>      case _ =&gt; List[Tree](coverageCall(expr))
</td>
          </tr><tr >
            <td class="black">165</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">166</td>
            <td>
</td>
          </tr><tr >
            <td class="green">167</td>
            <td>    private def instrumentBlockStats(stats: List[Tree]) = stats.foldLeft(List[Tree]()) { (list, stat) =&gt;
</td>
          </tr><tr >
            <td class="black">168</td>
            <td>      stat match {
</td>
          </tr><tr >
            <td class="green">169</td>
            <td>        case _:ValDef =&gt; list ::: List(stat)
</td>
          </tr><tr >
            <td class="green">170</td>
            <td>        case _:DefDef =&gt; list ::: List(stat)
</td>
          </tr><tr >
            <td class="red">171</td>
            <td>        case _:LabelDef =&gt; list <span class="non">::: List(stat)
</span></td>
          </tr><tr >
            <td class="green">172</td>
            <td>        case _:Block =&gt; list ::: List(stat)
</td>
          </tr><tr >
            <td class="green">173</td>
            <td>        case _ =&gt; list ::: List(coverageCall(stat), stat)
</td>
          </tr><tr >
            <td class="black">174</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">175</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">176</td>
            <td>
</td>
          </tr><tr >
            <td class="black">177</td>
            <td>    private def instrumentBody(t: Tree) = t match {
</td>
          </tr><tr >
            <td class="green">178</td>
            <td>      case Select(_,_) =&gt; instrumentedBlock(t)
</td>
          </tr><tr >
            <td class="green">179</td>
            <td>      case Apply(_,_) =&gt; instrumentedBlock(t)
</td>
          </tr><tr >
            <td class="green">180</td>
            <td>      case TypeApply(_,_) =&gt; instrumentedBlock(t)
</td>
          </tr><tr >
            <td class="green">181</td>
            <td>      case Literal(Constant(())) =&gt; t
</td>
          </tr><tr >
            <td class="green">182</td>
            <td>      case Literal(_) =&gt; instrumentedBlock(t)
</td>
          </tr><tr >
            <td class="green">183</td>
            <td>      case Ident(_) =&gt; instrumentedBlock(t)
</td>
          </tr><tr >
            <td class="green">184</td>
            <td>      case Throw(_) =&gt; instrumentedBlock(t)
</td>
          </tr><tr >
            <td class="green">185</td>
            <td>      case Return(_) =&gt; instrumentedBlock(t)
</td>
          </tr><tr >
            <td class="green">186</td>
            <td>      case _ =&gt; t
</td>
          </tr><tr >
            <td class="black">187</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">188</td>
            <td>
</td>
          </tr><tr >
            <td class="black">189</td>
            <td>    private def instrumentedBlock(t: Tree) = {
</td>
          </tr><tr >
            <td class="green">190</td>
            <td>      copy.Block(t, List(coverageCall(t)), t)
</td>
          </tr><tr >
            <td class="black">191</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">192</td>
            <td>
</td>
          </tr><tr >
            <td class="black">193</td>
            <td>    private def addPlaceHolder(template: Template) = {
</td>
          </tr><tr >
            <td class="green">194</td>
            <td>      if (!currentOwner.hasFlag(Flags.SYNTHETIC)) register(newId, template, true)
</td>
          </tr><tr >
            <td class="green">195</td>
            <td>      template
</td>
          </tr><tr >
            <td class="black">196</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">197</td>
            <td>
</td>
          </tr><tr >
            <td class="black">198</td>
            <td>    private def coverageCall(tree: Tree) = {
</td>
          </tr><tr >
            <td class="green">199</td>
            <td>      val id = newId
</td>
          </tr><tr >
            <td class="green">200</td>
            <td>      register(id, tree, false)
</td>
          </tr><tr >
            <td class="green">201</td>
            <td>      fitIntoTree(tree, rawCoverageCall(id))
</td>
          </tr><tr >
            <td class="black">202</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">203</td>
            <td>
</td>
          </tr><tr >
            <td class="black">204</td>
            <td>    private def fitIntoTree(orig: Tree, newTree: Tree) = {
</td>
          </tr><tr >
            <td class="green">205</td>
            <td>      localTyper.typed(atPos(orig.pos)(newTree))
</td>
          </tr><tr >
            <td class="black">206</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">207</td>
            <td>
</td>
          </tr><tr >
            <td class="black">208</td>
            <td>    private def rawCoverageCall(id: String) = {
</td>
          </tr><tr >
            <td class="green">209</td>
            <td>      val fun = Select(
</td>
          </tr><tr >
            <td class="black">210</td>
            <td>        Select(
</td>
          </tr><tr >
            <td class="black">211</td>
            <td>          Select(
</td>
          </tr><tr >
            <td class="black">212</td>
            <td>            Ident(&quot;reaktor&quot;),
</td>
          </tr><tr >
            <td class="black">213</td>
            <td>            newTermName(&quot;scct&quot;)
</td>
          </tr><tr >
            <td class="black">214</td>
            <td>          ),
</td>
          </tr><tr >
            <td class="black">215</td>
            <td>          newTermName(&quot;Coverage&quot;)
</td>
          </tr><tr >
            <td class="black">216</td>
            <td>        ),
</td>
          </tr><tr >
            <td class="black">217</td>
            <td>        newTermName(&quot;invoked&quot;)
</td>
          </tr><tr >
            <td class="black">218</td>
            <td>      )
</td>
          </tr><tr >
            <td class="green">219</td>
            <td>      Apply(fun, List(Literal(id)))
</td>
          </tr><tr >
            <td class="black">220</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">221</td>
            <td>
</td>
          </tr><tr >
            <td class="black">222</td>
            <td>    private def register(id: String, tree: Tree, placeHolder: Boolean) {
</td>
          </tr><tr >
            <td class="green">223</td>
            <td>      val fileName = tree.pos.source.get.file.file.getAbsolutePath
</td>
          </tr><tr >
            <td class="green">224</td>
            <td>      val name = Name(fileName, classType, packageName, className(currentClass))
</td>
          </tr><tr >
            <td class="green">225</td>
            <td>      data = new CoveredBlock(id, name, findMinOffset(tree), placeHolder) :: data
</td>
          </tr><tr >
            <td class="black">226</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">227</td>
            <td>
</td>
          </tr><tr >
            <td class="green">228</td>
            <td>    private def findMinOffset(tree: Tree) = new MinimumOffsetFinder().offsetFor(tree)
</td>
          </tr><tr >
            <td class="black">229</td>
            <td>
</td>
          </tr><tr >
            <td class="black">230</td>
            <td>    private def classType = {
</td>
          </tr><tr >
            <td class="black">231</td>
            <td>      if (currentOwner.isRoot)
</td>
          </tr><tr >
            <td class="red">232</td>
            <td>        <span class="non">ClassTypes.Root
</span></td>
          </tr><tr >
            <td class="black">233</td>
            <td>      else if (currentClass.isModule || currentClass.isModuleClass)
</td>
          </tr><tr >
            <td class="green">234</td>
            <td>        ClassTypes.Object
</td>
          </tr><tr >
            <td class="black">235</td>
            <td>      else if (currentClass.isTrait)
</td>
          </tr><tr >
            <td class="green">236</td>
            <td>        ClassTypes.Trait
</td>
          </tr><tr >
            <td class="green">237</td>
            <td>      else ClassTypes.Class
</td>
          </tr><tr >
            <td class="black">238</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">239</td>
            <td>
</td>
          </tr><tr >
            <td class="black">240</td>
            <td>    private def packageName = {
</td>
          </tr><tr >
            <td class="yellow">241</td>
            <td>      if (currentOwner.isRoot) <span class="non">&quot;&lt;root&gt;&quot; else </span>currentPackage.fullNameString
</td>
          </tr><tr >
            <td class="black">242</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">243</td>
            <td>
</td>
          </tr><tr >
            <td class="black">244</td>
            <td>    private def className(curr: Symbol): String =
</td>
          </tr><tr >
            <td class="black">245</td>
            <td>      if (curr.isRoot)
</td>
          </tr><tr >
            <td class="red">246</td>
            <td>        <span class="non">&quot;&lt;root&gt;&quot;
</span></td>
          </tr><tr >
            <td class="black">247</td>
            <td>      else if (curr.isAnonymousClass)
</td>
          </tr><tr >
            <td class="red">248</td>
            <td>        <span class="non">className(curr.owner.enclClass)
</span></td>
          </tr><tr >
            <td class="black">249</td>
            <td>      else if (curr.owner.isPackageClass)
</td>
          </tr><tr >
            <td class="green">250</td>
            <td>        curr.simpleName.toString
</td>
          </tr><tr >
            <td class="green">251</td>
            <td>      else className(curr.owner.enclClass) + &quot;.&quot; + curr.simpleName.toString //owner.fullNameString
</td>
          </tr><tr >
            <td class="black">252</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">253</td>
            <td>
</td>
          </tr><tr id="Class_reaktor_scct_ScctTransformComponent_MinimumOffsetFinder">
            <td class="green">254</td>
            <td>  class MinimumOffsetFinder extends Traverser {
</td>
          </tr><tr >
            <td class="green">255</td>
            <td>    var min = Integer.MAX_VALUE
</td>
          </tr><tr >
            <td class="black">256</td>
            <td>    override def traverse(tree: Tree) {
</td>
          </tr><tr >
            <td class="green">257</td>
            <td>      tree.pos.offset.foreach { current =&gt;
</td>
          </tr><tr >
            <td class="green">258</td>
            <td>        if (current &lt; min) min = current
</td>
          </tr><tr >
            <td class="black">259</td>
            <td>      }
</td>
          </tr><tr >
            <td class="green">260</td>
            <td>      super.traverse(tree)
</td>
          </tr><tr >
            <td class="black">261</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">262</td>
            <td>     
</td>
          </tr><tr >
            <td class="black">263</td>
            <td>    def offsetFor(tree: Tree): Int = {
</td>
          </tr><tr >
            <td class="green">264</td>
            <td>      min = Integer.MAX_VALUE
</td>
          </tr><tr >
            <td class="green">265</td>
            <td>      super.apply(tree)
</td>
          </tr><tr >
            <td class="green">266</td>
            <td>      min
</td>
          </tr><tr >
            <td class="black">267</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">268</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">269</td>
            <td>
</td>
          </tr><tr >
            <td class="black">270</td>
            <td>}</td>
          </tr></tbody></table></body>
</html>