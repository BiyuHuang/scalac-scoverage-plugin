<table class="classes"><tbody><tr>
      <td class="barContainerLeft"><a href="#">Users/mtkopone/projects/scct/scct/src/main/scala/reaktor/scct/<span class="header">ScctInstrumentPlugin.scala</span></a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">91 %</div>
        <div class="greenBar" style="width:182px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct_scct_src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctInstrumentPlugin"><img src="class.png"></img>ScctInstrumentPlugin</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct_scct_src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent"><img src="class.png"></img>ScctTransformComponent</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">80 %</div>
        <div class="greenBar" style="width:160px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct_scct_src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent_ClassRegisterer"><img src="class.png"></img>ScctTransformComponent.ClassRegisterer</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct_scct_src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent_Instrumenter"><img src="class.png"></img>ScctTransformComponent.Instrumenter</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">96 %</div>
        <div class="greenBar" style="width:192px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct_scct_src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent_MinimumOffsetFinder"><img src="class.png"></img>ScctTransformComponent.MinimumOffsetFinder</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr></tbody></table><table class="source"><tbody><tr >
            <td class="black">1</td>
            <td>package reaktor.scct
</td>
          </tr><tr >
            <td class="black">2</td>
            <td>
</td>
          </tr><tr >
            <td class="black">3</td>
            <td>import tools.nsc.plugins.{PluginComponent, Plugin}
</td>
          </tr><tr >
            <td class="black">4</td>
            <td>import java.io.File
</td>
          </tr><tr >
            <td class="black">5</td>
            <td>import tools.nsc.transform.{Transform, TypingTransformers}
</td>
          </tr><tr >
            <td class="black">6</td>
            <td>import tools.nsc.symtab.Flags
</td>
          </tr><tr >
            <td class="black">7</td>
            <td>import tools.nsc.{Phase, Global}
</td>
          </tr><tr >
            <td class="black">8</td>
            <td>
</td>
          </tr><tr id="Class_reaktor_scct_ScctInstrumentPlugin">
            <td class="green">9</td>
            <td>class ScctInstrumentPlugin(val global: Global) extends Plugin {
</td>
          </tr><tr >
            <td class="green">10</td>
            <td>  val name = &quot;scct&quot;
</td>
          </tr><tr >
            <td class="green">11</td>
            <td>  val description = &quot;Scala code coverage instrumentation plugin.&quot;
</td>
          </tr><tr >
            <td class="green">12</td>
            <td>  val runsAfter = &quot;refchecks&quot;
</td>
          </tr><tr >
            <td class="green">13</td>
            <td>  val components = List(new ScctTransformComponent(global))
</td>
          </tr><tr >
            <td class="black">14</td>
            <td>}
</td>
          </tr><tr >
            <td class="black">15</td>
            <td>
</td>
          </tr><tr id="Class_reaktor_scct_ScctTransformComponent">
            <td class="green">16</td>
            <td>class ScctTransformComponent(val global: Global) extends PluginComponent with TypingTransformers with Transform {
</td>
          </tr><tr >
            <td class="black">17</td>
            <td>  import global._
</td>
          </tr><tr >
            <td class="black">18</td>
            <td>  import global.definitions._
</td>
          </tr><tr >
            <td class="black">19</td>
            <td>  import posAssigner.atPos
</td>
          </tr><tr >
            <td class="green">20</td>
            <td>  val runsAfter = &quot;refchecks&quot;
</td>
          </tr><tr >
            <td class="green">21</td>
            <td>  val phaseName = &quot;scctInstrumentation&quot;
</td>
          </tr><tr >
            <td class="green">22</td>
            <td>  def newTransformer(unit: CompilationUnit) = new Instrumenter(unit)
</td>
          </tr><tr >
            <td class="black">23</td>
            <td>
</td>
          </tr><tr >
            <td class="green">24</td>
            <td>  var debug = false
</td>
          </tr><tr >
            <td class="green">25</td>
            <td>  var saveData = true  
</td>
          </tr><tr >
            <td class="green">26</td>
            <td>  var counter = 0L
</td>
          </tr><tr >
            <td class="green">27</td>
            <td>  var data: List[CoveredBlock] = Nil
</td>
          </tr><tr >
            <td class="green">28</td>
            <td>  lazy val coverageFile = new File(global.settings.outdir.value, &quot;coverage.data&quot;)
</td>
          </tr><tr >
            <td class="green">29</td>
            <td>  def newId = { counter += 1; counter.toString }
</td>
          </tr><tr >
            <td class="black">30</td>
            <td>
</td>
          </tr><tr >
            <td class="green">31</td>
            <td>  override def newPhase(prev: scala.tools.nsc.Phase): StdPhase = new Phase(prev) {
</td>
          </tr><tr >
            <td class="black">32</td>
            <td>    override def run {
</td>
          </tr><tr >
            <td class="green">33</td>
            <td>      clearMetadata
</td>
          </tr><tr >
            <td class="green">34</td>
            <td>      super.run
</td>
          </tr><tr >
            <td class="green">35</td>
            <td>      saveMetadata
</td>
          </tr><tr >
            <td class="black">36</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">37</td>
            <td>    private def clearMetadata {
</td>
          </tr><tr >
            <td class="yellow">38</td>
            <td>      if (coverageFile.exists) <span class="non">coverageFile.delete
</span></td>
          </tr><tr >
            <td class="black">39</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">40</td>
            <td>    private def saveMetadata {
</td>
          </tr><tr >
            <td class="green">41</td>
            <td>      if (saveData) {
</td>
          </tr><tr >
            <td class="red">42</td>
            <td>        <span class="non">println(&quot;scct: Saving coverage data.&quot;)
</span></td>
          </tr><tr >
            <td class="red">43</td>
            <td>        <span class="non">MetadataPickler.toFile(data, coverageFile)
</span></td>
          </tr><tr >
            <td class="black">44</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">45</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">46</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">47</td>
            <td>
</td>
          </tr><tr id="Class_reaktor_scct_ScctTransformComponent_Instrumenter">
            <td class="green">48</td>
            <td>  class Instrumenter(unit: CompilationUnit) extends TypingTransformer(unit) {
</td>
          </tr><tr >
            <td class="black">49</td>
            <td>
</td>
          </tr><tr >
            <td class="black">50</td>
            <td>    override def transformUnit(unit: CompilationUnit) {
</td>
          </tr><tr >
            <td class="yellow">51</td>
            <td>      if (debug) <span class="non">treeBrowser.browse(List(unit))
</span></td>
          </tr><tr >
            <td class="green">52</td>
            <td>      registerClasses(unit.body)
</td>
          </tr><tr >
            <td class="green">53</td>
            <td>      super.transformUnit(unit)
</td>
          </tr><tr >
            <td class="yellow">54</td>
            <td>      if (debug) <span class="non">treeBrowser.browse(List(unit))
</span></td>
          </tr><tr >
            <td class="black">55</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">56</td>
            <td>
</td>
          </tr><tr >
            <td class="black">57</td>
            <td>    override def transform(tree: Tree) = {
</td>
          </tr><tr >
            <td class="green">58</td>
            <td>      val (continue, result) = preprocess(tree)
</td>
          </tr><tr >
            <td class="green">59</td>
            <td>      if (continue) super.transform(result) else result
</td>
          </tr><tr >
            <td class="black">60</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">61</td>
            <td>
</td>
          </tr><tr >
            <td class="green">62</td>
            <td>    private def hasSkipAnnotation(md: MemberDef) = md.mods.annotations.exists(_.tpe.safeToString == classOf[uncovered].getName)
</td>
          </tr><tr >
            <td class="green">63</td>
            <td>    private def isSynthetic(t: Tree) = t.hasSymbol &amp;&amp; t.symbol.hasFlag(Flags.SYNTHETIC) &amp;&amp; !t.symbol.isAnonymousFunction
</td>
          </tr><tr >
            <td class="green">64</td>
            <td>    private def isObjectOrTraitConstructor(s: Symbol) = s.isConstructor &amp;&amp; (currentClass.isModuleClass || currentClass.isTrait)
</td>
          </tr><tr >
            <td class="green">65</td>
            <td>    private def isGeneratedMethod(t: DefDef) = !t.symbol.isConstructor &amp;&amp; t.pos.offset == currentClass.pos.offset
</td>
          </tr><tr >
            <td class="green">66</td>
            <td>    private def isAbstractMethod(t: DefDef) = t.symbol.isDeferred
</td>
          </tr><tr >
            <td class="green">67</td>
            <td>    private def isNonLazyStableMethodOrAccessor(t: DefDef) = !t.symbol.hasFlag(Flags.LAZY) &amp;&amp; (t.symbol.hasFlag(Flags.STABLE | Flags.ACCESSOR | Flags.PARAMACCESSOR))
</td>
          </tr><tr >
            <td class="black">68</td>
            <td>
</td>
          </tr><tr >
            <td class="green">69</td>
            <td>    def preprocess(t: Tree): Tuple2[Boolean, Tree] = t match {
</td>
          </tr><tr >
            <td class="green">70</td>
            <td>      case _ if isSynthetic(t) =&gt; (false, t)
</td>
          </tr><tr >
            <td class="green">71</td>
            <td>      case md: MemberDef if hasSkipAnnotation(md) =&gt; (false, t)
</td>
          </tr><tr >
            <td class="green">72</td>
            <td>      case dd: DefDef if isNonLazyStableMethodOrAccessor(dd) =&gt; (false, t)
</td>
          </tr><tr >
            <td class="green">73</td>
            <td>      case dd: DefDef if isAbstractMethod(dd) =&gt; (false, t)
</td>
          </tr><tr >
            <td class="green">74</td>
            <td>      case dd: DefDef if isObjectOrTraitConstructor(t.symbol) =&gt; (false, t)
</td>
          </tr><tr >
            <td class="green">75</td>
            <td>      case dd: DefDef if isGeneratedMethod(dd) =&gt; (false, t)
</td>
          </tr><tr >
            <td class="black">76</td>
            <td>
</td>
          </tr><tr >
            <td class="green">77</td>
            <td>      case dd: DefDef if (t.symbol.isConstructor) =&gt; {
</td>
          </tr><tr >
            <td class="green">78</td>
            <td>        val block @ Block(list, expr @ Literal(_)) = dd.rhs
</td>
          </tr><tr >
            <td class="green">79</td>
            <td>        val (head:Apply) :: tail = list
</td>
          </tr><tr >
            <td class="green">80</td>
            <td>        val newTail: List[Tree] = instrument(super.transformStats(tail, currentOwner)) ::: List(coverageCall(block))
</td>
          </tr><tr >
            <td class="green">81</td>
            <td>        val newApply: Apply = copy.Apply(head, head.fun, super.transformTrees(head.args))
</td>
          </tr><tr >
            <td class="green">82</td>
            <td>        val newStats: List[Tree] = newApply :: newTail
</td>
          </tr><tr >
            <td class="green">83</td>
            <td>        val newRhs = copy.Block(block, newStats, expr)
</td>
          </tr><tr >
            <td class="green">84</td>
            <td>        (false, copy.DefDef(t, dd.mods, dd.name, dd.tparams, dd.vparamss, dd.tpt, newRhs))
</td>
          </tr><tr >
            <td class="black">85</td>
            <td>      }
</td>
          </tr><tr >
            <td class="green">86</td>
            <td>      case dd @ DefDef(_,_,_,_,_,b @ Block(List(a @ Assign(lhs,rhs)), _)) if (t.symbol.hasFlag(Flags.LAZY)) =&gt; {
</td>
          </tr><tr >
            <td class="green">87</td>
            <td>        val newAssign = copy.Assign(a, lhs, recurse(rhs))
</td>
          </tr><tr >
            <td class="green">88</td>
            <td>        val newBlock = copy.Block(b, List(newAssign), b.expr)
</td>
          </tr><tr >
            <td class="green">89</td>
            <td>        (false, copy.DefDef(t, dd.mods, dd.name, dd.tparams, dd.vparamss, dd.tpt, newBlock))
</td>
          </tr><tr >
            <td class="black">90</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">91</td>
            <td>      case dd: DefDef =&gt; {
</td>
          </tr><tr >
            <td class="green">92</td>
            <td>        (false, copy.DefDef(t, dd.mods, dd.name, dd.tparams, dd.vparamss, dd.tpt, recurse(dd.rhs)))
</td>
          </tr><tr >
            <td class="black">93</td>
            <td>      }
</td>
          </tr><tr >
            <td class="green">94</td>
            <td>      case vd: ValDef if (vd.symbol.hasFlag(Flags.ACCESSOR | Flags.PARAMACCESSOR)) =&gt; {
</td>
          </tr><tr >
            <td class="green">95</td>
            <td>        (false, t)
</td>
          </tr><tr >
            <td class="black">96</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">97</td>
            <td>      case vd: ValDef =&gt; {
</td>
          </tr><tr >
            <td class="green">98</td>
            <td>        (false, copy.ValDef(t, vd.mods, vd.name, vd.tpt, recurse(vd.rhs)))
</td>
          </tr><tr >
            <td class="black">99</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">100</td>
            <td>      case Template(parents, self, body) =&gt; {
</td>
          </tr><tr >
            <td class="green">101</td>
            <td>        (false, copy.Template(t, parents, self, instrument(super.transformStats(body, t.symbol))))
</td>
          </tr><tr >
            <td class="black">102</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">103</td>
            <td>      case If(cond, thenp, elsep) =&gt; {
</td>
          </tr><tr >
            <td class="green">104</td>
            <td>        (false, copy.If(t, recurse(cond), recurse(thenp), recurse(elsep)))
</td>
          </tr><tr >
            <td class="black">105</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">106</td>
            <td>      case Function(vparams, body) =&gt; {
</td>
          </tr><tr >
            <td class="green">107</td>
            <td>        (false, copy.Function(t, vparams, recurse(body)))
</td>
          </tr><tr >
            <td class="black">108</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">109</td>
            <td>      case Match(selector, cases) =&gt; {
</td>
          </tr><tr >
            <td class="green">110</td>
            <td>        (false, copy.Match(t, recurse(selector), super.transformCaseDefs(cases)))
</td>
          </tr><tr >
            <td class="black">111</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">112</td>
            <td>      case CaseDef(pat, guard, body) =&gt; {
</td>
          </tr><tr >
            <td class="green">113</td>
            <td>        (false, copy.CaseDef(t, pat, recurse(guard), recurse(body)))
</td>
          </tr><tr >
            <td class="black">114</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">115</td>
            <td>      case Try(block, catches, finalizer) =&gt; {
</td>
          </tr><tr >
            <td class="green">116</td>
            <td>        (false, copy.Try(t, recurse(block), super.transformCaseDefs(catches), recurse(finalizer)))
</td>
          </tr><tr >
            <td class="black">117</td>
            <td>      }
</td>
          </tr><tr >
            <td class="green">118</td>
            <td>      case LabelDef(name1, List(), i @ If(_, b @ Block(_, Apply(Ident(name2), List())), Literal(Constant(())))) if (name1 == name2 &amp;&amp; name1.startsWith(&quot;while&quot;)) =&gt; {
</td>
          </tr><tr >
            <td class="green">119</td>
            <td>        val newBlock = copy.Block(b, instrument(super.transformStats(b.stats, currentOwner)), b.expr)
</td>
          </tr><tr >
            <td class="green">120</td>
            <td>        val newIf = copy.If(i, recurse(i.cond), newBlock, i.elsep)
</td>
          </tr><tr >
            <td class="green">121</td>
            <td>        (false, copy.LabelDef(t, name1, List(), newIf))
</td>
          </tr><tr >
            <td class="black">122</td>
            <td>      }
</td>
          </tr><tr >
            <td class="green">123</td>
            <td>      case LabelDef(name1, List(), b @ Block(stats, i @ If(cond, Apply(Ident(name2), List()), Literal(Constant(()))))) if (name1 == name2 &amp;&amp; name1.startsWith(&quot;doWhile&quot;)) =&gt; {
</td>
          </tr><tr >
            <td class="green">124</td>
            <td>        val newIf = copy.If(i, recurse(i.cond), i.thenp, i.elsep)
</td>
          </tr><tr >
            <td class="green">125</td>
            <td>        val newBlock = copy.Block(b, instrument(super.transformStats(b.stats, currentOwner)), newIf)
</td>
          </tr><tr >
            <td class="green">126</td>
            <td>        (false, copy.LabelDef(t, name1, List(), newBlock))
</td>
          </tr><tr >
            <td class="black">127</td>
            <td>      }
</td>
          </tr><tr >
            <td class="black">128</td>
            <td>      case b: Block =&gt; {
</td>
          </tr><tr >
            <td class="green">129</td>
            <td>        val originalStats = instrument(super.transformStats(b.stats, currentOwner))
</td>
          </tr><tr >
            <td class="green">130</td>
            <td>        val stats = originalStats ::: (if (shouldInstrument(b.expr)) List(coverageCall(b.expr)) else List())
</td>
          </tr><tr >
            <td class="green">131</td>
            <td>        val expr = transform(b.expr)
</td>
          </tr><tr >
            <td class="green">132</td>
            <td>        (false, copy.Block(b, stats, expr))
</td>
          </tr><tr >
            <td class="black">133</td>
            <td>      }
</td>
          </tr><tr >
            <td class="green">134</td>
            <td>      case _ =&gt; (true, t)
</td>
          </tr><tr >
            <td class="black">135</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">136</td>
            <td>
</td>
          </tr><tr >
            <td class="green">137</td>
            <td>    def recurse(t: Tree) = if (shouldInstrument(t)) instrument(transform(t)) else transform(t)
</td>
          </tr><tr >
            <td class="black">138</td>
            <td>
</td>
          </tr><tr >
            <td class="green">139</td>
            <td>    def shouldInstrument(t: Tree) = t match {
</td>
          </tr><tr >
            <td class="green">140</td>
            <td>      case _:ClassDef =&gt; false
</td>
          </tr><tr >
            <td class="red">141</td>
            <td>      case _:Template =&gt; <span class="non">false
</span></td>
          </tr><tr >
            <td class="green">142</td>
            <td>      case _:TypeDef =&gt; false
</td>
          </tr><tr >
            <td class="green">143</td>
            <td>      case _:DefDef =&gt; false
</td>
          </tr><tr >
            <td class="green">144</td>
            <td>      case _:ValDef =&gt; false
</td>
          </tr><tr >
            <td class="green">145</td>
            <td>      case _:Block =&gt; false
</td>
          </tr><tr >
            <td class="green">146</td>
            <td>      case _:If =&gt; false
</td>
          </tr><tr >
            <td class="green">147</td>
            <td>      case _:Function =&gt; false
</td>
          </tr><tr >
            <td class="green">148</td>
            <td>      case _:Match =&gt; false
</td>
          </tr><tr >
            <td class="red">149</td>
            <td>      case _:CaseDef =&gt; <span class="non">false
</span></td>
          </tr><tr >
            <td class="green">150</td>
            <td>      case _:Try =&gt; false
</td>
          </tr><tr >
            <td class="green">151</td>
            <td>      case _:LabelDef =&gt; false
</td>
          </tr><tr >
            <td class="green">152</td>
            <td>      case EmptyTree =&gt; false
</td>
          </tr><tr >
            <td class="green">153</td>
            <td>      case Literal(Constant(())) =&gt; false
</td>
          </tr><tr >
            <td class="green">154</td>
            <td>      case _ =&gt; true
</td>
          </tr><tr >
            <td class="black">155</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">156</td>
            <td>
</td>
          </tr><tr >
            <td class="green">157</td>
            <td>    def instrument(t: Tree): Tree = copy.Block(t, List(coverageCall(t)), t)
</td>
          </tr><tr >
            <td class="black">158</td>
            <td>
</td>
          </tr><tr >
            <td class="green">159</td>
            <td>    def instrument(statements: List[Tree]): List[Tree] = statements.foldLeft(List[Tree]()) { (list, stat) =&gt;
</td>
          </tr><tr >
            <td class="green">160</td>
            <td>      if (shouldInstrument(stat)) list ::: List(coverageCall(stat), stat) else list ::: List(stat)
</td>
          </tr><tr >
            <td class="black">161</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">162</td>
            <td>
</td>
          </tr><tr >
            <td class="black">163</td>
            <td>    private def coverageCall(tree: Tree) = {
</td>
          </tr><tr >
            <td class="green">164</td>
            <td>      val id = newId
</td>
          </tr><tr >
            <td class="green">165</td>
            <td>      data = CoveredBlock(id, createName(currentOwner, tree), minOffset(tree), false) :: data
</td>
          </tr><tr >
            <td class="green">166</td>
            <td>      fitIntoTree(tree, rawCoverageCall(id))
</td>
          </tr><tr >
            <td class="black">167</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">168</td>
            <td>
</td>
          </tr><tr >
            <td class="black">169</td>
            <td>    private def fitIntoTree(orig: Tree, newTree: Tree) = {
</td>
          </tr><tr >
            <td class="green">170</td>
            <td>      localTyper.typed(atPos(orig.pos)(newTree))
</td>
          </tr><tr >
            <td class="black">171</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">172</td>
            <td>
</td>
          </tr><tr >
            <td class="black">173</td>
            <td>    private def rawCoverageCall(id: String) = {
</td>
          </tr><tr >
            <td class="green">174</td>
            <td>      val fun = Select( Select( Select(Ident(&quot;reaktor&quot;), newTermName(&quot;scct&quot;) ), newTermName(&quot;Coverage&quot;) ), newTermName(&quot;invoked&quot;) )
</td>
          </tr><tr >
            <td class="green">175</td>
            <td>      Apply(fun, List(Literal(id)))
</td>
          </tr><tr >
            <td class="black">176</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">177</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">178</td>
            <td>
</td>
          </tr><tr >
            <td class="black">179</td>
            <td>  private def createName(owner: Symbol, tree: Tree) =
</td>
          </tr><tr id="Class_reaktor_scct_ScctTransformComponent">
            <td class="green">180</td>
            <td>    Name(tree.pos.source.get.file.file.getAbsolutePath, classType(owner), packageName(tree, owner), className(tree, owner))
</td>
          </tr><tr >
            <td class="black">181</td>
            <td>
</td>
          </tr><tr >
            <td class="black">182</td>
            <td>  def className(tree: Tree, owner: Symbol): String = {
</td>
          </tr><tr >
            <td class="black">183</td>
            <td>    def fromSymbol(s: Symbol): String = {
</td>
          </tr><tr >
            <td class="green">184</td>
            <td>      def parent = s.owner.enclClass
</td>
          </tr><tr >
            <td class="yellow">185</td>
            <td>      if (s.isPackageClass) <span class="non">&quot;&quot;
</span></td>
          </tr><tr >
            <td class="green">186</td>
            <td>        else if (s.isAnonymousClass) fromSymbol(parent)
</td>
          </tr><tr >
            <td class="green">187</td>
            <td>        else if (parent.isPackageClass) s.simpleName.toString
</td>
          </tr><tr >
            <td class="green">188</td>
            <td>        else fromSymbol(parent) + &quot;.&quot; + s.simpleName
</td>
          </tr><tr >
            <td class="black">189</td>
            <td>    }
</td>
          </tr><tr >
            <td class="green">190</td>
            <td>    tree match {
</td>
          </tr><tr >
            <td class="green">191</td>
            <td>      case cd: ClassDef =&gt; fromSymbol(cd.symbol)
</td>
          </tr><tr >
            <td class="green">192</td>
            <td>      case _ =&gt; fromSymbol(owner.enclClass)
</td>
          </tr><tr >
            <td class="black">193</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">194</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">195</td>
            <td>
</td>
          </tr><tr >
            <td class="green">196</td>
            <td>  def packageName(tree: Tree, owner: Symbol): String = tree match {
</td>
          </tr><tr >
            <td class="red">197</td>
            <td>    case pd: PackageDef if <span class="non">pd.symbol.isEmptyPackage =&gt; &quot;&lt;root&gt;&quot;
</span></td>
          </tr><tr >
            <td class="red">198</td>
            <td>    case pd: PackageDef =&gt; <span class="non">pd.symbol.fullNameString
</span></td>
          </tr><tr >
            <td class="yellow">199</td>
            <td>    case _ =&gt; if (owner.isEmptyPackageClass || owner.isEmptyPackage) <span class="non">&quot;&lt;root&gt;&quot;
</span></td>
          </tr><tr >
            <td class="yellow">200</td>
            <td>                else if (owner.isPackage || owner.isPackageClass) <span class="non">owner.fullNameString
</span></td>
          </tr><tr >
            <td class="yellow">201</td>
            <td>                else if (owner.toplevelClass == NoSymbol) <span class="non">&quot;&lt;root&gt;&quot;
</span></td>
          </tr><tr >
            <td class="green">202</td>
            <td>                else if (owner.toplevelClass.owner.isEmptyPackageClass) &quot;&lt;root&gt;&quot;
</td>
          </tr><tr >
            <td class="green">203</td>
            <td>                else owner.toplevelClass.owner.fullNameString
</td>
          </tr><tr >
            <td class="black">204</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">205</td>
            <td>
</td>
          </tr><tr >
            <td class="black">206</td>
            <td>
</td>
          </tr><tr >
            <td class="black">207</td>
            <td>  def classType(s: Symbol) = {
</td>
          </tr><tr >
            <td class="yellow">208</td>
            <td>    if (s.isRoot) <span class="non">ClassTypes.Root
</span></td>
          </tr><tr >
            <td class="green">209</td>
            <td>      else if (s.isModule || s.isModuleClass) ClassTypes.Object
</td>
          </tr><tr >
            <td class="green">210</td>
            <td>      else if (s.isTrait) ClassTypes.Trait
</td>
          </tr><tr >
            <td class="green">211</td>
            <td>      else ClassTypes.Class
</td>
          </tr><tr >
            <td class="black">212</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">213</td>
            <td>
</td>
          </tr><tr >
            <td class="black">214</td>
            <td>
</td>
          </tr><tr >
            <td class="green">215</td>
            <td>  def minOffset(t: Tree) = new MinimumOffsetFinder().offsetFor(t)
</td>
          </tr><tr >
            <td class="black">216</td>
            <td>
</td>
          </tr><tr id="Class_reaktor_scct_ScctTransformComponent_MinimumOffsetFinder">
            <td class="green">217</td>
            <td>  class MinimumOffsetFinder extends Traverser {
</td>
          </tr><tr >
            <td class="green">218</td>
            <td>    var min = Integer.MAX_VALUE
</td>
          </tr><tr >
            <td class="black">219</td>
            <td>    override def traverse(t: Tree) {
</td>
          </tr><tr >
            <td class="green">220</td>
            <td>      t.pos.offset.foreach { curr =&gt;
</td>
          </tr><tr >
            <td class="green">221</td>
            <td>        if (curr &lt; min) min = curr
</td>
          </tr><tr >
            <td class="black">222</td>
            <td>      }
</td>
          </tr><tr >
            <td class="green">223</td>
            <td>      super.traverse(t)
</td>
          </tr><tr >
            <td class="black">224</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">225</td>
            <td>
</td>
          </tr><tr >
            <td class="black">226</td>
            <td>    def offsetFor(t: Tree): Int = {
</td>
          </tr><tr >
            <td class="green">227</td>
            <td>      min = Integer.MAX_VALUE
</td>
          </tr><tr >
            <td class="green">228</td>
            <td>      super.apply(t)
</td>
          </tr><tr >
            <td class="green">229</td>
            <td>      min
</td>
          </tr><tr >
            <td class="black">230</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">231</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">232</td>
            <td>
</td>
          </tr><tr >
            <td class="black">233</td>
            <td>
</td>
          </tr><tr id="Class_reaktor_scct_ScctTransformComponent">
            <td class="green">234</td>
            <td>  def registerClasses(t: Tree) = new ClassRegisterer().apply(t)
</td>
          </tr><tr >
            <td class="black">235</td>
            <td>
</td>
          </tr><tr id="Class_reaktor_scct_ScctTransformComponent_ClassRegisterer">
            <td class="green">236</td>
            <td>  class ClassRegisterer extends Traverser {
</td>
          </tr><tr >
            <td class="black">237</td>
            <td>    override def traverse(t: Tree) = {
</td>
          </tr><tr >
            <td class="green">238</td>
            <td>      t match {
</td>
          </tr><tr >
            <td class="green">239</td>
            <td>        case cd: ClassDef if (!cd.symbol.hasFlag(Flags.SYNTHETIC)) =&gt; {
</td>
          </tr><tr >
            <td class="green">240</td>
            <td>          data = CoveredBlock(newId, createName(cd.symbol, t), minOffset(t), true) :: data
</td>
          </tr><tr >
            <td class="black">241</td>
            <td>        }
</td>
          </tr><tr >
            <td class="black">242</td>
            <td>        case _ =&gt;
</td>
          </tr><tr >
            <td class="black">243</td>
            <td>      }
</td>
          </tr><tr >
            <td class="green">244</td>
            <td>      super.traverse(t)
</td>
          </tr><tr >
            <td class="black">245</td>
            <td>    }
</td>
          </tr><tr >
            <td class="black">246</td>
            <td>  }
</td>
          </tr><tr >
            <td class="black">247</td>
            <td>}</td>
          </tr></tbody></table>