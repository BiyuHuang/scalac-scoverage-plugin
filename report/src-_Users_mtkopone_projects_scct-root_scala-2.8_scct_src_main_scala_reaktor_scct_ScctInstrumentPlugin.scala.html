<table class="classes"><tbody><tr>
      <td class="barContainerLeft"><a href="#">&#x200B;reaktor/&#x200B;scct/<span class="header">&#x200B;ScctInstrumentPlugin.scala</span></a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">93 %</div>
        <div class="greenBar" style="width:186px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct-root_scala-2.8_scct_src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctInstrumentPlugin"><img src="class.png"></img>ScctInstrumentPlugin</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct-root_scala-2.8_scct_src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent"><img src="class.png"></img>ScctTransformComponent</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">84 %</div>
        <div class="greenBar" style="width:168px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct-root_scala-2.8_scct_src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent_ClassRegisterer"><img src="class.png"></img>ScctTransformComponent.ClassRegisterer</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct-root_scala-2.8_scct_src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent_Instrumenter"><img src="class.png"></img>ScctTransformComponent.Instrumenter</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">96 %</div>
        <div class="greenBar" style="width:192px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-_Users_mtkopone_projects_scct-root_scala-2.8_scct_src_main_scala_reaktor_scct_ScctInstrumentPlugin.scala.html#Class_reaktor_scct_ScctTransformComponent_MinimumOffsetFinder"><img src="class.png"></img>ScctTransformComponent.MinimumOffsetFinder</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">100 %</div>
        <div class="greenBar" style="width:200px;">&nbsp;</div>
      </div>
    </div></td>
    </tr></tbody></table><table class="source"><tbody><tr>
            <td class="black">1</td>
            <td>package reaktor.scct
</td>
          </tr><tr>
            <td class="black">2</td>
            <td>
</td>
          </tr><tr>
            <td class="black">3</td>
            <td>import tools.nsc.plugins.{PluginComponent, Plugin}
</td>
          </tr><tr>
            <td class="black">4</td>
            <td>import java.io.File
</td>
          </tr><tr>
            <td class="black">5</td>
            <td>import tools.nsc.transform.{Transform, TypingTransformers}
</td>
          </tr><tr>
            <td class="black">6</td>
            <td>import tools.nsc.symtab.Flags
</td>
          </tr><tr>
            <td class="black">7</td>
            <td>import tools.nsc.{Phase, Global}
</td>
          </tr><tr>
            <td class="black">8</td>
            <td>
</td>
          </tr><tr>
            <td class="green">9</td>
            <td><a id="Class_reaktor_scct_ScctInstrumentPlugin"></a>class ScctInstrumentPlugin(val global: Global) extends Plugin {
</td>
          </tr><tr>
            <td class="green">10</td>
            <td>  val name = &quot;scct&quot;
</td>
          </tr><tr>
            <td class="green">11</td>
            <td>  val description = &quot;Scala code coverage instrumentation plugin.&quot;
</td>
          </tr><tr>
            <td class="green">12</td>
            <td>  val runsAfter = List(&quot;refchecks&quot;)
</td>
          </tr><tr>
            <td class="green">13</td>
            <td>  val components = List(new ScctTransformComponent(global))
</td>
          </tr><tr>
            <td class="black">14</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">15</td>
            <td>
</td>
          </tr><tr>
            <td class="green">16</td>
            <td><a id="Class_reaktor_scct_ScctTransformComponent"></a>class ScctTransformComponent(val global: Global) extends PluginComponent with TypingTransformers with Transform {
</td>
          </tr><tr>
            <td class="black">17</td>
            <td>  import global._
</td>
          </tr><tr>
            <td class="black">18</td>
            <td>  import global.definitions._
</td>
          </tr><tr>
            <td class="green">19</td>
            <td>  override val runsRightAfter = Some(&quot;refchecks&quot;)
</td>
          </tr><tr>
            <td class="green">20</td>
            <td>  val runsAfter = List[String](runsRightAfter.get)
</td>
          </tr><tr>
            <td class="green">21</td>
            <td>  val phaseName = &quot;scctInstrumentation&quot;
</td>
          </tr><tr>
            <td class="green">22</td>
            <td>  def newTransformer(unit: CompilationUnit) = new Instrumenter(unit)
</td>
          </tr><tr>
            <td class="black">23</td>
            <td>
</td>
          </tr><tr>
            <td class="green">24</td>
            <td>  var debug = false
</td>
          </tr><tr>
            <td class="green">25</td>
            <td>  var saveData = true  
</td>
          </tr><tr>
            <td class="green">26</td>
            <td>  var counter = 0L
</td>
          </tr><tr>
            <td class="green">27</td>
            <td>  var data: List[CoveredBlock] = Nil
</td>
          </tr><tr>
            <td class="green">28</td>
            <td>  lazy val coverageFile = new File(global.settings.outdir.value, &quot;coverage.data&quot;)
</td>
          </tr><tr>
            <td class="green">29</td>
            <td>  def newId = { counter += 1; counter.toString }
</td>
          </tr><tr>
            <td class="black">30</td>
            <td>
</td>
          </tr><tr>
            <td class="green">31</td>
            <td>  override def newPhase(prev: scala.tools.nsc.Phase): StdPhase = new Phase(prev) {
</td>
          </tr><tr>
            <td class="black">32</td>
            <td>    override def run {
</td>
          </tr><tr>
            <td class="black">33</td>
            <td>      clearMetadata
</td>
          </tr><tr>
            <td class="black">34</td>
            <td>      super.run
</td>
          </tr><tr>
            <td class="black">35</td>
            <td>      saveMetadata
</td>
          </tr><tr>
            <td class="black">36</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">37</td>
            <td>    private def clearMetadata {
</td>
          </tr><tr>
            <td class="black">38</td>
            <td>      if (coverageFile.exists) coverageFile.delete
</td>
          </tr><tr>
            <td class="black">39</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">40</td>
            <td>    private def saveMetadata {
</td>
          </tr><tr>
            <td class="black">41</td>
            <td>      if (saveData) {
</td>
          </tr><tr>
            <td class="black">42</td>
            <td>        println(&quot;scct: Saving coverage data.&quot;)
</td>
          </tr><tr>
            <td class="black">43</td>
            <td>        MetadataPickler.toFile(data, coverageFile)
</td>
          </tr><tr>
            <td class="black">44</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">45</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">46</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">47</td>
            <td>
</td>
          </tr><tr>
            <td class="green">48</td>
            <td><a id="Class_reaktor_scct_ScctTransformComponent_Instrumenter"></a>  class Instrumenter(unit: CompilationUnit) extends TypingTransformer(unit) {
</td>
          </tr><tr>
            <td class="black">49</td>
            <td>
</td>
          </tr><tr>
            <td class="black">50</td>
            <td>    override def transformUnit(unit: CompilationUnit) {
</td>
          </tr><tr>
            <td class="yellow">51</td>
            <td>      if (debug) <span class="non">treeBrowser.browse(List(unit))
</span></td>
          </tr><tr>
            <td class="green">52</td>
            <td>      registerClasses(unit.body)
</td>
          </tr><tr>
            <td class="green">53</td>
            <td>      super.transformUnit(unit)
</td>
          </tr><tr>
            <td class="yellow">54</td>
            <td>      if (debug) <span class="non">treeBrowser.browse(List(unit))
</span></td>
          </tr><tr>
            <td class="black">55</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">56</td>
            <td>
</td>
          </tr><tr>
            <td class="black">57</td>
            <td>    override def transform(tree: Tree) = {
</td>
          </tr><tr>
            <td class="green">58</td>
            <td>      val (continue, result) = preprocess(tree)
</td>
          </tr><tr>
            <td class="green">59</td>
            <td>      if (continue) super.transform(result) else result
</td>
          </tr><tr>
            <td class="black">60</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">61</td>
            <td>
</td>
          </tr><tr>
            <td class="green">62</td>
            <td>    private def hasSkipAnnotation(t: Tree) = t.hasSymbol &amp;&amp; t.symbol.hasAnnotation(definitions.getClass(&quot;reaktor.scct.uncovered&quot;))
</td>
          </tr><tr>
            <td class="green">63</td>
            <td>    private def isSynthetic(t: Tree) = t.hasSymbol &amp;&amp; t.symbol.isSynthetic &amp;&amp; !t.symbol.isAnonymousFunction
</td>
          </tr><tr>
            <td class="green">64</td>
            <td>    private def isObjectOrTraitConstructor(s: Symbol) = s.isConstructor &amp;&amp; (currentClass.isModuleClass || currentClass.isTrait)
</td>
          </tr><tr>
            <td class="green">65</td>
            <td>    private def isGeneratedMethod(t: DefDef) = !t.symbol.isConstructor &amp;&amp; t.pos.point == currentClass.pos.point
</td>
          </tr><tr>
            <td class="green">66</td>
            <td>    private def isAbstractMethod(t: DefDef) = t.symbol.isDeferred
</td>
          </tr><tr>
            <td class="green">67</td>
            <td>    private def isNonLazyStableMethodOrAccessor(t: DefDef) = !t.symbol.isLazy &amp;&amp; (t.symbol.isStable || t.symbol.isGetterOrSetter)
</td>
          </tr><tr>
            <td class="green">68</td>
            <td>    private def isInAnonymousClass = currentClass.isAnonymousClass
</td>
          </tr><tr>
            <td class="black">69</td>
            <td>
</td>
          </tr><tr>
            <td class="green">70</td>
            <td>    def preprocess(t: Tree): Tuple2[Boolean, Tree] = t match {
</td>
          </tr><tr>
            <td class="green">71</td>
            <td>      case _ if isSynthetic(t) =&gt; (false, t)
</td>
          </tr><tr>
            <td class="green">72</td>
            <td>      case _ if hasSkipAnnotation(t) =&gt; (false, t)
</td>
          </tr><tr>
            <td class="green">73</td>
            <td>      case dd: DefDef if isNonLazyStableMethodOrAccessor(dd) =&gt; (false, t)
</td>
          </tr><tr>
            <td class="green">74</td>
            <td>      case dd: DefDef if isAbstractMethod(dd) =&gt; (false, t)
</td>
          </tr><tr>
            <td class="green">75</td>
            <td>      case dd: DefDef if isObjectOrTraitConstructor(t.symbol) =&gt; (false, t)
</td>
          </tr><tr>
            <td class="green">76</td>
            <td>      case dd: DefDef if isGeneratedMethod(dd) =&gt; (false, t)
</td>
          </tr><tr>
            <td class="green">77</td>
            <td>      case dd: DefDef if isInAnonymousClass =&gt; (false, t)
</td>
          </tr><tr>
            <td class="black">78</td>
            <td>
</td>
          </tr><tr>
            <td class="green">79</td>
            <td>      case dd: DefDef if (t.symbol.isConstructor) =&gt; {
</td>
          </tr><tr>
            <td class="green">80</td>
            <td>        (false, instrumentConstructor(t.symbol.isPrimaryConstructor, dd))
</td>
          </tr><tr>
            <td class="black">81</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">82</td>
            <td>      case dd @ DefDef(_,_,_,_,_,b @ Block(List(a @ Assign(lhs,rhs)), _)) if (t.symbol.isLazy) =&gt; {
</td>
          </tr><tr>
            <td class="green">83</td>
            <td>        val newAssign = treeCopy.Assign(a, lhs, recurse(rhs))
</td>
          </tr><tr>
            <td class="green">84</td>
            <td>        val newBlock = treeCopy.Block(b, List(newAssign), b.expr)
</td>
          </tr><tr>
            <td class="green">85</td>
            <td>        (false, treeCopy.DefDef(t, dd.mods, dd.name, dd.tparams, dd.vparamss, dd.tpt, newBlock))
</td>
          </tr><tr>
            <td class="black">86</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">87</td>
            <td>      case dd: DefDef =&gt; {
</td>
          </tr><tr>
            <td class="green">88</td>
            <td>        (false, treeCopy.DefDef(t, dd.mods, dd.name, dd.tparams, dd.vparamss, dd.tpt, recurse(dd.rhs)))
</td>
          </tr><tr>
            <td class="black">89</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">90</td>
            <td>      case vd: ValDef if (vd.symbol.isParamAccessor) =&gt; {
</td>
          </tr><tr>
            <td class="green">91</td>
            <td>        (false, t)
</td>
          </tr><tr>
            <td class="black">92</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">93</td>
            <td>      case vd: ValDef =&gt; {
</td>
          </tr><tr>
            <td class="green">94</td>
            <td>        (false, treeCopy.ValDef(t, vd.mods, vd.name, vd.tpt, recurse(vd.rhs)))
</td>
          </tr><tr>
            <td class="black">95</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">96</td>
            <td>      case Template(parents, self, body) =&gt; {
</td>
          </tr><tr>
            <td class="green">97</td>
            <td>        (false, treeCopy.Template(t, parents, self, instrument(super.transformStats(body, t.symbol))))
</td>
          </tr><tr>
            <td class="black">98</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">99</td>
            <td>      case If(cond, thenp, elsep) =&gt; {
</td>
          </tr><tr>
            <td class="green">100</td>
            <td>        (false, treeCopy.If(t, recurse(cond), recurse(thenp), recurse(elsep)))
</td>
          </tr><tr>
            <td class="black">101</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">102</td>
            <td>      case Function(vparams, body) =&gt; {
</td>
          </tr><tr>
            <td class="green">103</td>
            <td>        (false, treeCopy.Function(t, vparams, recurse(body)))
</td>
          </tr><tr>
            <td class="black">104</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">105</td>
            <td>      case Match(selector, cases) =&gt; {
</td>
          </tr><tr>
            <td class="green">106</td>
            <td>        (false, treeCopy.Match(t, recurse(selector), super.transformCaseDefs(cases)))
</td>
          </tr><tr>
            <td class="black">107</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">108</td>
            <td>      case CaseDef(pat, guard, body) =&gt; {
</td>
          </tr><tr>
            <td class="green">109</td>
            <td>        (false, treeCopy.CaseDef(t, pat, recurse(guard), recurse(body)))
</td>
          </tr><tr>
            <td class="black">110</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">111</td>
            <td>      case Try(block, catches, finalizer) =&gt; {
</td>
          </tr><tr>
            <td class="green">112</td>
            <td>        (false, treeCopy.Try(t, recurse(block), super.transformCaseDefs(catches), recurse(finalizer)))
</td>
          </tr><tr>
            <td class="black">113</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">114</td>
            <td>      case LabelDef(name1, List(), i @ If(_, b @ Block(_, Apply(Ident(name2), List())), Literal(Constant(())))) if (name1 == name2 &amp;&amp; name1.startsWith(&quot;while&quot;)) =&gt; {
</td>
          </tr><tr>
            <td class="green">115</td>
            <td>        val newBlock = treeCopy.Block(b, instrument(super.transformStats(b.stats, currentOwner)), b.expr)
</td>
          </tr><tr>
            <td class="green">116</td>
            <td>        val newIf = treeCopy.If(i, recurse(i.cond), newBlock, i.elsep)
</td>
          </tr><tr>
            <td class="green">117</td>
            <td>        (false, treeCopy.LabelDef(t, name1, List(), newIf))
</td>
          </tr><tr>
            <td class="black">118</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">119</td>
            <td>      case LabelDef(name1, List(), b @ Block(stats, i @ If(cond, Apply(Ident(name2), List()), Literal(Constant(()))))) if (name1 == name2 &amp;&amp; name1.startsWith(&quot;doWhile&quot;)) =&gt; {
</td>
          </tr><tr>
            <td class="green">120</td>
            <td>        val newIf = treeCopy.If(i, recurse(i.cond), i.thenp, i.elsep)
</td>
          </tr><tr>
            <td class="green">121</td>
            <td>        val newBlock = treeCopy.Block(b, instrument(super.transformStats(b.stats, currentOwner)), newIf)
</td>
          </tr><tr>
            <td class="green">122</td>
            <td>        (false, treeCopy.LabelDef(t, name1, List(), newBlock))
</td>
          </tr><tr>
            <td class="black">123</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">124</td>
            <td>      case b: Block =&gt; {
</td>
          </tr><tr>
            <td class="green">125</td>
            <td>        val originalStats = instrument(super.transformStats(b.stats, currentOwner))
</td>
          </tr><tr>
            <td class="green">126</td>
            <td>        val stats = originalStats ::: (if (shouldInstrument(b.expr)) List(coverageCall(b.expr)) else List())
</td>
          </tr><tr>
            <td class="green">127</td>
            <td>        val expr = transform(b.expr)
</td>
          </tr><tr>
            <td class="green">128</td>
            <td>        (false, treeCopy.Block(b, stats, expr))
</td>
          </tr><tr>
            <td class="black">129</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">130</td>
            <td>      case _ =&gt; (true, t)
</td>
          </tr><tr>
            <td class="black">131</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">132</td>
            <td>
</td>
          </tr><tr>
            <td class="green">133</td>
            <td>    def recurse(t: Tree) = if (shouldInstrument(t)) instrument(transform(t)) else transform(t)
</td>
          </tr><tr>
            <td class="black">134</td>
            <td>
</td>
          </tr><tr>
            <td class="green">135</td>
            <td>    def shouldInstrument(t: Tree) = t match {
</td>
          </tr><tr>
            <td class="green">136</td>
            <td>      case _:ClassDef =&gt; false
</td>
          </tr><tr>
            <td class="red">137</td>
            <td>      case _:Template =&gt; <span class="non">false
</span></td>
          </tr><tr>
            <td class="green">138</td>
            <td>      case _:TypeDef =&gt; false
</td>
          </tr><tr>
            <td class="green">139</td>
            <td>      case _:DefDef =&gt; false
</td>
          </tr><tr>
            <td class="green">140</td>
            <td>      case _:ValDef =&gt; false
</td>
          </tr><tr>
            <td class="green">141</td>
            <td>      case _:Block =&gt; false
</td>
          </tr><tr>
            <td class="green">142</td>
            <td>      case _:If =&gt; false
</td>
          </tr><tr>
            <td class="green">143</td>
            <td>      case _:Function =&gt; false
</td>
          </tr><tr>
            <td class="green">144</td>
            <td>      case _:Match =&gt; false
</td>
          </tr><tr>
            <td class="red">145</td>
            <td>      case _:CaseDef =&gt; <span class="non">false
</span></td>
          </tr><tr>
            <td class="green">146</td>
            <td>      case _:Try =&gt; false
</td>
          </tr><tr>
            <td class="green">147</td>
            <td>      case _:LabelDef =&gt; false
</td>
          </tr><tr>
            <td class="green">148</td>
            <td>      case EmptyTree =&gt; false
</td>
          </tr><tr>
            <td class="green">149</td>
            <td>      case Literal(Constant(())) =&gt; false
</td>
          </tr><tr>
            <td class="green">150</td>
            <td>      case _ =&gt; true
</td>
          </tr><tr>
            <td class="black">151</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">152</td>
            <td>
</td>
          </tr><tr>
            <td class="green">153</td>
            <td>    def instrument(t: Tree): Tree = treeCopy.Block(t, List(coverageCall(t)), t)
</td>
          </tr><tr>
            <td class="black">154</td>
            <td>
</td>
          </tr><tr>
            <td class="green">155</td>
            <td>    def instrument(statements: List[Tree]): List[Tree] = statements.foldLeft(List[Tree]()) { (list, stat) =&gt;
</td>
          </tr><tr>
            <td class="green">156</td>
            <td>      if (shouldInstrument(stat)) list ::: List(coverageCall(stat), stat) else list ::: List(stat)
</td>
          </tr><tr>
            <td class="black">157</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">158</td>
            <td>
</td>
          </tr><tr>
            <td class="black">159</td>
            <td>    def instrumentConstructor(primary: Boolean, dd: DefDef) = {
</td>
          </tr><tr>
            <td class="green">160</td>
            <td>      val block @ Block(list, expr @ Literal(_)) = dd.rhs
</td>
          </tr><tr>
            <td class="black">161</td>
            <td>
</td>
          </tr><tr>
            <td class="black">162</td>
            <td>      def instrumentConstructorStatements(list: List[Tree], acc: List[Tree]): List[Tree] = {
</td>
          </tr><tr>
            <td class="green">163</td>
            <td>        list match {
</td>
          </tr><tr>
            <td class="green">164</td>
            <td>          case Nil =&gt; acc.reverse
</td>
          </tr><tr>
            <td class="green">165</td>
            <td>          case head :: tail =&gt; head match {
</td>
          </tr><tr>
            <td class="black">166</td>
            <td>            case vd: ValDef =&gt; {
</td>
          </tr><tr>
            <td class="green">167</td>
            <td>              instrumentConstructorStatements(tail, recurse(vd) :: acc)
</td>
          </tr><tr>
            <td class="black">168</td>
            <td>            }
</td>
          </tr><tr>
            <td class="green">169</td>
            <td>            case a @ Apply(Select(_, selector), _) if selector.toString == &quot;&lt;init&gt;&quot; =&gt; {
</td>
          </tr><tr>
            <td class="green">170</td>
            <td>              val applyInstrumentation = if (primary) coverageCall(block) else coverageCall(a)
</td>
          </tr><tr>
            <td class="green">171</td>
            <td>              val newApply = treeCopy.Apply(a, a.fun, super.transformTrees(a.args))
</td>
          </tr><tr>
            <td class="green">172</td>
            <td>              instrumentConstructorStatements(tail, applyInstrumentation :: newApply :: acc)
</td>
          </tr><tr>
            <td class="black">173</td>
            <td>            }
</td>
          </tr><tr>
            <td class="black">174</td>
            <td>            case _ =&gt; {
</td>
          </tr><tr>
            <td class="green">175</td>
            <td>              val newTail = instrument(super.transformStats(list, currentOwner))
</td>
          </tr><tr>
            <td class="green">176</td>
            <td>              acc.reverse ::: newTail
</td>
          </tr><tr>
            <td class="black">177</td>
            <td>            }
</td>
          </tr><tr>
            <td class="black">178</td>
            <td>          }
</td>
          </tr><tr>
            <td class="black">179</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">180</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">181</td>
            <td>
</td>
          </tr><tr>
            <td class="green">182</td>
            <td>      val newStats = instrumentConstructorStatements(list, List[Tree]())
</td>
          </tr><tr>
            <td class="green">183</td>
            <td>      val newRhs = treeCopy.Block(block, newStats, expr)
</td>
          </tr><tr>
            <td class="green">184</td>
            <td>      treeCopy.DefDef(dd, dd.mods, dd.name, dd.tparams, dd.vparamss, dd.tpt, newRhs)
</td>
          </tr><tr>
            <td class="black">185</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">186</td>
            <td>
</td>
          </tr><tr>
            <td class="black">187</td>
            <td>    private def coverageCall(tree: Tree) = {
</td>
          </tr><tr>
            <td class="green">188</td>
            <td>      val id = newId
</td>
          </tr><tr>
            <td class="green">189</td>
            <td>      data = CoveredBlock(id, createName(currentOwner, tree), minOffset(tree), false) :: data
</td>
          </tr><tr>
            <td class="green">190</td>
            <td>      fitIntoTree(tree, rawCoverageCall(id))
</td>
          </tr><tr>
            <td class="black">191</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">192</td>
            <td>
</td>
          </tr><tr>
            <td class="black">193</td>
            <td>    private def fitIntoTree(orig: Tree, newTree: Tree) = {
</td>
          </tr><tr>
            <td class="green">194</td>
            <td>      localTyper.typed(atPos(orig.pos)(newTree))
</td>
          </tr><tr>
            <td class="black">195</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">196</td>
            <td>
</td>
          </tr><tr>
            <td class="black">197</td>
            <td>    private def rawCoverageCall(id: String) = {
</td>
          </tr><tr>
            <td class="green">198</td>
            <td>      val fun = Select( Select( Select(Ident(&quot;reaktor&quot;), newTermName(&quot;scct&quot;) ), newTermName(&quot;Coverage&quot;) ), newTermName(&quot;invoked&quot;) )
</td>
          </tr><tr>
            <td class="green">199</td>
            <td>      Apply(fun, List(Literal(id)))
</td>
          </tr><tr>
            <td class="black">200</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">201</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">202</td>
            <td>
</td>
          </tr><tr>
            <td class="black">203</td>
            <td>  private def createName(owner: Symbol, tree: Tree) =
</td>
          </tr><tr>
            <td class="green">204</td>
            <td>    Name(tree.pos.source.file.file.getAbsolutePath, classType(owner), packageName(tree, owner), className(tree, owner))
</td>
          </tr><tr>
            <td class="black">205</td>
            <td>
</td>
          </tr><tr>
            <td class="black">206</td>
            <td>  def className(tree: Tree, owner: Symbol): String = {
</td>
          </tr><tr>
            <td class="black">207</td>
            <td>    def fromSymbol(s: Symbol): String = {
</td>
          </tr><tr>
            <td class="green">208</td>
            <td>      def parent = s.owner.enclClass
</td>
          </tr><tr>
            <td class="yellow">209</td>
            <td>      if (s.isPackageClass) <span class="non">&quot;&quot;
</span></td>
          </tr><tr>
            <td class="green">210</td>
            <td>        else if (s.isAnonymousClass) fromSymbol(parent)
</td>
          </tr><tr>
            <td class="green">211</td>
            <td>        else if (s.isPackageObjectClass) &quot;&quot;
</td>
          </tr><tr>
            <td class="green">212</td>
            <td>        else if (parent.isPackageClass || parent.isPackageObjectClass) s.simpleName.toString
</td>
          </tr><tr>
            <td class="green">213</td>
            <td>        else fromSymbol(parent) + &quot;.&quot; + s.simpleName
</td>
          </tr><tr>
            <td class="black">214</td>
            <td>    }
</td>
          </tr><tr>
            <td class="green">215</td>
            <td>    tree match {
</td>
          </tr><tr>
            <td class="green">216</td>
            <td>      case cd: ClassDef =&gt; fromSymbol(cd.symbol)
</td>
          </tr><tr>
            <td class="green">217</td>
            <td>      case _ =&gt; fromSymbol(owner.enclClass)
</td>
          </tr><tr>
            <td class="black">218</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">219</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">220</td>
            <td>
</td>
          </tr><tr>
            <td class="green">221</td>
            <td>  def packageName(tree: Tree, owner: Symbol): String = tree match {
</td>
          </tr><tr>
            <td class="red">222</td>
            <td>    case pd: PackageDef if <span class="non">pd.symbol.isEmptyPackage =&gt; &quot;&lt;root&gt;&quot;
</span></td>
          </tr><tr>
            <td class="red">223</td>
            <td>    case pd: PackageDef =&gt; <span class="non">pd.symbol.fullName.toString
</span></td>
          </tr><tr>
            <td class="yellow">224</td>
            <td>    case _ =&gt; if (owner.isEmptyPackageClass || owner.isEmptyPackage) <span class="non">&quot;&lt;root&gt;&quot;
</span></td>
          </tr><tr>
            <td class="yellow">225</td>
            <td>                else if (owner.isPackage || owner.isPackageClass) <span class="non">owner.fullName.toString
</span></td>
          </tr><tr>
            <td class="yellow">226</td>
            <td>                else if (owner.toplevelClass == NoSymbol) <span class="non">&quot;&lt;root&gt;&quot;
</span></td>
          </tr><tr>
            <td class="green">227</td>
            <td>                else if (owner.toplevelClass.owner.isEmptyPackageClass) &quot;&lt;root&gt;&quot;
</td>
          </tr><tr>
            <td class="green">228</td>
            <td>                else owner.toplevelClass.owner.fullName.toString
</td>
          </tr><tr>
            <td class="black">229</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">230</td>
            <td>
</td>
          </tr><tr>
            <td class="black">231</td>
            <td>
</td>
          </tr><tr>
            <td class="black">232</td>
            <td>  def classType(s: Symbol) = {
</td>
          </tr><tr>
            <td class="yellow">233</td>
            <td>    if (s.isRoot) <span class="non">ClassTypes.Root
</span></td>
          </tr><tr>
            <td class="green">234</td>
            <td>      else if (s.isPackageObjectClass) ClassTypes.Package
</td>
          </tr><tr>
            <td class="green">235</td>
            <td>      else if (s.isModule || s.isModuleClass) ClassTypes.Object
</td>
          </tr><tr>
            <td class="green">236</td>
            <td>      else if (s.isTrait) ClassTypes.Trait
</td>
          </tr><tr>
            <td class="green">237</td>
            <td>      else ClassTypes.Class
</td>
          </tr><tr>
            <td class="black">238</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">239</td>
            <td>
</td>
          </tr><tr>
            <td class="black">240</td>
            <td>
</td>
          </tr><tr>
            <td class="green">241</td>
            <td>  def minOffset(t: Tree) = new MinimumOffsetFinder().offsetFor(t)
</td>
          </tr><tr>
            <td class="black">242</td>
            <td>
</td>
          </tr><tr>
            <td class="green">243</td>
            <td><a id="Class_reaktor_scct_ScctTransformComponent_MinimumOffsetFinder"></a>  class MinimumOffsetFinder extends Traverser {
</td>
          </tr><tr>
            <td class="green">244</td>
            <td>    var min = Integer.MAX_VALUE
</td>
          </tr><tr>
            <td class="black">245</td>
            <td>    override def traverse(t: Tree) {
</td>
          </tr><tr>
            <td class="green">246</td>
            <td>      if (t.pos.isDefined) {
</td>
          </tr><tr>
            <td class="green">247</td>
            <td>        val curr = t.pos.startOrPoint
</td>
          </tr><tr>
            <td class="green">248</td>
            <td>        if (curr &lt; min) min = curr
</td>
          </tr><tr>
            <td class="black">249</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">250</td>
            <td>      super.traverse(t)
</td>
          </tr><tr>
            <td class="black">251</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">252</td>
            <td>
</td>
          </tr><tr>
            <td class="black">253</td>
            <td>    def offsetFor(t: Tree): Int = {
</td>
          </tr><tr>
            <td class="green">254</td>
            <td>      min = Integer.MAX_VALUE
</td>
          </tr><tr>
            <td class="green">255</td>
            <td>      super.apply(t)
</td>
          </tr><tr>
            <td class="green">256</td>
            <td>      min
</td>
          </tr><tr>
            <td class="black">257</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">258</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">259</td>
            <td>
</td>
          </tr><tr>
            <td class="black">260</td>
            <td>
</td>
          </tr><tr>
            <td class="green">261</td>
            <td>  def registerClasses(t: Tree) = new ClassRegisterer().apply(t)
</td>
          </tr><tr>
            <td class="black">262</td>
            <td>
</td>
          </tr><tr>
            <td class="green">263</td>
            <td><a id="Class_reaktor_scct_ScctTransformComponent_ClassRegisterer"></a>  class ClassRegisterer extends Traverser {
</td>
          </tr><tr>
            <td class="black">264</td>
            <td>    override def traverse(t: Tree) = {
</td>
          </tr><tr>
            <td class="green">265</td>
            <td>      t match {
</td>
          </tr><tr>
            <td class="green">266</td>
            <td>        case cd: ClassDef if (!cd.symbol.isSynthetic) =&gt; {
</td>
          </tr><tr>
            <td class="green">267</td>
            <td>          data = CoveredBlock(newId, createName(cd.symbol, t), minOffset(t), true) :: data
</td>
          </tr><tr>
            <td class="black">268</td>
            <td>        }
</td>
          </tr><tr>
            <td class="black">269</td>
            <td>        case _ =&gt;
</td>
          </tr><tr>
            <td class="black">270</td>
            <td>      }
</td>
          </tr><tr>
            <td class="green">271</td>
            <td>      super.traverse(t)
</td>
          </tr><tr>
            <td class="black">272</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">273</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">274</td>
            <td>}
</td>
          </tr></tbody></table>